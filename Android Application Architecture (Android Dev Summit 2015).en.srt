1
00:00:00,000 --> 00:00:02,590


2
00:00:02,590 --> 00:00:04,029
ADAM POWELL: Hi there.

3
00:00:04,030 --> 00:00:07,250
So as Dave said, we're always
a little bit more personable

4
00:00:07,250 --> 00:00:08,000
right after lunch.

5
00:00:08,000 --> 00:00:10,629
We're also a little bit more
excitable right after coffee.

6
00:00:10,629 --> 00:00:12,170
So you're catching
us at a good time.

7
00:00:12,170 --> 00:00:13,960
YIGIT BOYAR: Yeah,
just had coffee.

8
00:00:13,960 --> 00:00:15,510
ADAM POWELL: So this talk
is about Android application

9
00:00:15,510 --> 00:00:16,104
architecture.

10
00:00:16,104 --> 00:00:16,770
I'm Adam Powell.

11
00:00:16,770 --> 00:00:18,870
I'm on the Android
framework team.

12
00:00:18,870 --> 00:00:19,270
YIGIT BOYAR: I'm Yigit Boyar.

13
00:00:19,270 --> 00:00:20,890
I'm also in the
Android framework team.

14
00:00:20,890 --> 00:00:22,010
ADAM POWELL: So this
is actually going

15
00:00:22,010 --> 00:00:23,770
to be a little bit of a
special extended edition

16
00:00:23,770 --> 00:00:26,186
version of a talk that we gave
earlier this year at Google

17
00:00:26,186 --> 00:00:28,150
I/O. And just like every
good special edition,

18
00:00:28,150 --> 00:00:30,159
the original version
isn't available on video.

19
00:00:30,160 --> 00:00:32,420
So here you are.

20
00:00:32,420 --> 00:00:35,360
So the important thing about
application architecture

21
00:00:35,360 --> 00:00:38,580
is, really, you need to act
early in your applications.

22
00:00:38,580 --> 00:00:40,250
As soon as you
start writing code,

23
00:00:40,250 --> 00:00:41,750
you've made these
decisions that are

24
00:00:41,750 --> 00:00:44,112
going to affect how your
application is going to be

25
00:00:44,112 --> 00:00:45,320
developed from there forward.

26
00:00:45,320 --> 00:00:48,610


27
00:00:48,610 --> 00:00:51,638
So those decisions
stick with you.

28
00:00:51,639 --> 00:00:53,930
These really, really deeply
influence your application.

29
00:00:53,930 --> 00:00:56,120
And we're going to show
you a few of the ways

30
00:00:56,120 --> 00:00:58,280
that this really affects
how you might write

31
00:00:58,280 --> 00:01:00,360
your app as you move forward.

32
00:01:00,360 --> 00:01:02,040
It really makes it
easier or harder

33
00:01:02,040 --> 00:01:04,300
to think about the problems
that you're really setting

34
00:01:04,300 --> 00:01:06,860
to solve in your application.

35
00:01:06,860 --> 00:01:09,876
So you might be asking, OK,
well, which patterns do I use?

36
00:01:09,876 --> 00:01:11,250
There's a lot of
stuff out there.

37
00:01:11,250 --> 00:01:14,870
And you can really get
into a lot of alphabet soup

38
00:01:14,870 --> 00:01:18,170
as you start looking over all
of the different prescriptive

39
00:01:18,170 --> 00:01:19,930
patterns that you
can look into--

40
00:01:19,930 --> 00:01:21,304
YIGIT BOYAR: I'm super confused.

41
00:01:21,304 --> 00:01:23,720
ADAM POWELL: Yeah, I mean,
I've got all these things here.

42
00:01:23,720 --> 00:01:25,777
YIGIT BOYAR: That's
me, by the way.

43
00:01:25,778 --> 00:01:29,350
That's me, this cartoon.

44
00:01:29,350 --> 00:01:31,580
ADAM POWELL: So this isn't
a survey of libraries.

45
00:01:31,580 --> 00:01:34,190
That's not what we're
here to talk about today.

46
00:01:34,190 --> 00:01:36,450
There really are a lot of
great libraries out there.

47
00:01:36,450 --> 00:01:38,283
And you should really
look into many of them

48
00:01:38,283 --> 00:01:40,420
and see what they
can do for you.

49
00:01:40,420 --> 00:01:42,320
And the trends change quickly.

50
00:01:42,320 --> 00:01:44,820
The challenges you're going
to face are really timeless.

51
00:01:44,820 --> 00:01:47,429
The properties of some of these
devices that we're writing for

52
00:01:47,430 --> 00:01:50,780
have been the same properties
from the first time

53
00:01:50,780 --> 00:01:53,210
any one of us held a smartphone.

54
00:01:53,210 --> 00:01:55,720
And really, lava flow
happens over time.

55
00:01:55,720 --> 00:01:57,810
This is kind of this
phenomenon where,

56
00:01:57,810 --> 00:02:00,690
after your code goes through
a number of refactorings,

57
00:02:00,690 --> 00:02:02,940
there isn't really kind of
an overarching principle

58
00:02:02,940 --> 00:02:04,450
that ties it all
together anymore.

59
00:02:04,450 --> 00:02:06,556
Someone new who comes
to your code base

60
00:02:06,556 --> 00:02:08,139
may or may not
understand what's going

61
00:02:08,139 --> 00:02:11,030
on as you start piling up
all of these different pieces

62
00:02:11,030 --> 00:02:14,490
that really no
longer fit together.

63
00:02:14,490 --> 00:02:16,840
The important takeaway
from this is to architect

64
00:02:16,840 --> 00:02:18,640
for user experience.

65
00:02:18,640 --> 00:02:21,070
Really, nobody in
your user base is

66
00:02:21,070 --> 00:02:23,359
going to care exactly
what patterns you used

67
00:02:23,360 --> 00:02:24,830
to produce your application.

68
00:02:24,830 --> 00:02:27,205
They're going to care about
the experience that they have

69
00:02:27,205 --> 00:02:29,850
while they've got
it in their hand.

70
00:02:29,850 --> 00:02:33,527
YIGIT BOYAR: All right, so
let's look at some examples.

71
00:02:33,527 --> 00:02:34,359
There's some videos.

72
00:02:34,360 --> 00:02:36,430
So here's an application.

73
00:02:36,430 --> 00:02:37,700
It's very simple.

74
00:02:37,700 --> 00:02:41,310
I'm posting a comment on
a photo, trying to type.

75
00:02:41,310 --> 00:02:42,950
All right, there you go, Send.

76
00:02:42,950 --> 00:02:43,850
And I'm waiting.

77
00:02:43,850 --> 00:02:45,120
Why am I waiting?

78
00:02:45,120 --> 00:02:46,260
I have no idea.

79
00:02:46,260 --> 00:02:47,910
I'm just waiting, waiting.

80
00:02:47,910 --> 00:02:49,329
All right, it sent.

81
00:02:49,330 --> 00:02:53,120
So what was the problem here?

82
00:02:53,120 --> 00:02:55,700
So what's happening was, the
user clicks on the Send button.

83
00:02:55,700 --> 00:02:59,470
It goes to your controller,
goes to your network,

84
00:02:59,470 --> 00:03:02,430
network comes back whenever
it wants to come back.

85
00:03:02,430 --> 00:03:04,079
And then you update your UI.

86
00:03:04,079 --> 00:03:05,870
Meanwhile, you blocked
the user because you

87
00:03:05,870 --> 00:03:06,911
don't know what happened.

88
00:03:06,911 --> 00:03:08,850
Maybe the comment will not go.

89
00:03:08,850 --> 00:03:11,250
What if we get rid of
this, introduce something

90
00:03:11,250 --> 00:03:13,980
you can call a model, which
is your storage, which

91
00:03:13,980 --> 00:03:16,500
is where you keep your
comments and everything?

92
00:03:16,500 --> 00:03:18,960
So then when the user
hits the Send button,

93
00:03:18,960 --> 00:03:22,410
you keep it in your
model, update your UI,

94
00:03:22,410 --> 00:03:25,859
then tell the network
that this has been added.

95
00:03:25,860 --> 00:03:29,200
And when the network comes
back, you can update your UI.

96
00:03:29,200 --> 00:03:31,739
So let's look at the
same example, this time

97
00:03:31,740 --> 00:03:33,640
with the fix, how it looks.

98
00:03:33,640 --> 00:03:34,880
So I come here.

99
00:03:34,880 --> 00:03:37,710
I type my comment--
the same comment

100
00:03:37,710 --> 00:03:39,960
so you make sure it's
the same use case.

101
00:03:39,960 --> 00:03:41,410
I send it.

102
00:03:41,410 --> 00:03:42,600
I still see the comment.

103
00:03:42,600 --> 00:03:45,320
It's a little bit gray,
but I see it there.

104
00:03:45,320 --> 00:03:48,310
When the network finally
comes back, it turns black.

105
00:03:48,310 --> 00:03:49,850
User has a clue.

106
00:03:49,850 --> 00:03:51,440
You can design it better.

107
00:03:51,440 --> 00:03:52,480
I couldn't.

108
00:03:52,480 --> 00:03:55,570
But that's the idea.

109
00:03:55,570 --> 00:03:57,290
You give the feedback instantly.

110
00:03:57,290 --> 00:03:59,040
ADAM POWELL: Your
designers are wonderful.

111
00:03:59,040 --> 00:04:01,874
Make sure that you
appreciate them.

112
00:04:01,874 --> 00:04:04,290
YIGIT BOYAR: I told you, why
did you give me a design job?

113
00:04:04,290 --> 00:04:06,980


114
00:04:06,980 --> 00:04:09,670
OK, let's look at one more demo.

115
00:04:09,670 --> 00:04:11,519
It's the same puppy.

116
00:04:11,520 --> 00:04:13,680
So I keep commenting
that I really like it.

117
00:04:13,680 --> 00:04:14,570
I keep commenting.

118
00:04:14,570 --> 00:04:18,279
And I hit Send.

119
00:04:18,279 --> 00:04:20,690
OK, you're going to see
that it's greyed out.

120
00:04:20,690 --> 00:04:22,329
I see the responses only.

121
00:04:22,329 --> 00:04:22,870
That's great.

122
00:04:22,870 --> 00:04:23,700
It turns black.

123
00:04:23,700 --> 00:04:24,580
That's great.

124
00:04:24,580 --> 00:04:26,109
I go back to that page again.

125
00:04:26,110 --> 00:04:26,790
It's empty.

126
00:04:26,790 --> 00:04:30,300
Like, I was here
literally two seconds ago.

127
00:04:30,300 --> 00:04:30,970
I came back.

128
00:04:30,970 --> 00:04:33,960
I come back to the page,
and it's not there.

129
00:04:33,960 --> 00:04:35,370
This is inconsistent.

130
00:04:35,370 --> 00:04:37,960
I feel like something got lost.

131
00:04:37,960 --> 00:04:40,750
So what was happening here?

132
00:04:40,750 --> 00:04:45,520
So the view controller, as we
said before, told the model,

133
00:04:45,520 --> 00:04:47,750
model told the
network, it came back,

134
00:04:47,750 --> 00:04:49,780
we updated the UI-- great.

135
00:04:49,780 --> 00:04:53,130
But the problem is the
model didn't have anything.

136
00:04:53,130 --> 00:04:57,380
It only is still
fed by the network.

137
00:04:57,380 --> 00:05:00,730
What if, instead, you
kept a persistent model?

138
00:05:00,730 --> 00:05:03,020
So the idea is that your
data stays on your client.

139
00:05:03,020 --> 00:05:04,880
There's something
that you can always

140
00:05:04,880 --> 00:05:08,000
access unless the phone crashes,
which-- you can't do anything

141
00:05:08,000 --> 00:05:09,210
in that case.

142
00:05:09,210 --> 00:05:11,320
Instead, we have some
application logic

143
00:05:11,320 --> 00:05:14,280
that is responsible
to synchronize network

144
00:05:14,280 --> 00:05:15,909
and your persistent model.

145
00:05:15,910 --> 00:05:18,230
It's really important
to look at this problem

146
00:05:18,230 --> 00:05:22,130
as a synchronization problem
rather than making API calls.

147
00:05:22,130 --> 00:05:23,330
That simplifies a lot.

148
00:05:23,330 --> 00:05:26,960
So this application logic
syncs with the network,

149
00:05:26,960 --> 00:05:28,789
fetches whatever
you want to fetch,

150
00:05:28,790 --> 00:05:31,700
updates the model, then just
notifies in the event-- OK,

151
00:05:31,700 --> 00:05:32,200
I'm done.

152
00:05:32,200 --> 00:05:33,760
I made some changes.

153
00:05:33,760 --> 00:05:36,659
Hey guys, if anybody wants to
know about it, here they are.

154
00:05:36,660 --> 00:05:39,550
And then your view
controller goes and fetches

155
00:05:39,550 --> 00:05:41,850
the data and updates the view.

156
00:05:41,850 --> 00:05:43,876
Let's say the user clicked
on the Send button.

157
00:05:43,876 --> 00:05:46,989
The view control tells the
application logic, OK, I

158
00:05:46,990 --> 00:05:48,020
have this comment.

159
00:05:48,020 --> 00:05:50,260
Please send it.

160
00:05:50,260 --> 00:05:52,087
The logic instantly
updates the disk.

161
00:05:52,087 --> 00:05:53,670
That's the first
thing you have to do.

162
00:05:53,670 --> 00:05:56,420
You update the local
storage and tell, hey,

163
00:05:56,420 --> 00:05:57,570
I updated this comment.

164
00:05:57,570 --> 00:05:58,930
I added this comment.

165
00:05:58,930 --> 00:06:01,720
And it also calls the network.

166
00:06:01,720 --> 00:06:03,570
Now, there's two things
going on right now.

167
00:06:03,570 --> 00:06:05,680
While you're making
the network query,

168
00:06:05,680 --> 00:06:07,590
the view controller
gets notified.

169
00:06:07,590 --> 00:06:10,179
OK, I have a new comment
to fetch, goes to model,

170
00:06:10,180 --> 00:06:11,630
update the UI.

171
00:06:11,630 --> 00:06:14,690
When the network finally
returns, the application logic

172
00:06:14,690 --> 00:06:16,920
updates the model
again and says, OK,

173
00:06:16,920 --> 00:06:18,760
I seek to comment to server.

174
00:06:18,760 --> 00:06:21,830
If anybody's inserted,
do something.

175
00:06:21,830 --> 00:06:25,280
And then the view controller
goes, updates the view again.

176
00:06:25,280 --> 00:06:28,229
So everybody has
very simple duties.

177
00:06:28,230 --> 00:06:30,960
And they are decoupled.

178
00:06:30,960 --> 00:06:34,229
So see how it looks when
we implement it properly.

179
00:06:34,230 --> 00:06:35,000
I come here.

180
00:06:35,000 --> 00:06:35,840
It's instant.

181
00:06:35,840 --> 00:06:38,109
Because it's coming
from the local storage.

182
00:06:38,110 --> 00:06:41,560
It cannot be slow unless
something is going really bad

183
00:06:41,560 --> 00:06:45,276
on your device, which
sometimes happens.

184
00:06:45,276 --> 00:06:53,800
All right, so one more
example-- OK, it's running.

185
00:06:53,800 --> 00:06:56,890
So I'm so excited that
I keep sending comments.

186
00:06:56,890 --> 00:06:58,940
But they're only seeing
the first comment I sent.

187
00:06:58,940 --> 00:07:02,035
Something is-- oh, OK,
they just showed up.

188
00:07:02,035 --> 00:07:03,410
ADAM POWELL: What
happened there?

189
00:07:03,410 --> 00:07:04,493
YIGIT BOYAR: I don't know.

190
00:07:04,493 --> 00:07:05,719
What happened there?

191
00:07:05,720 --> 00:07:08,390
Now I figure out
what happened there.

192
00:07:08,390 --> 00:07:09,539
So this was my background.

193
00:07:09,540 --> 00:07:11,860
Because I had this great
pool on the background

194
00:07:11,860 --> 00:07:13,750
that processes all
these things one by one

195
00:07:13,750 --> 00:07:15,730
so that I don't create
too many threads.

196
00:07:15,730 --> 00:07:18,950
So And I loaded the activity
to-- a fetch bitmap job

197
00:07:18,950 --> 00:07:22,280
came for the photo, and the
other one to load the comments

198
00:07:22,280 --> 00:07:23,479
from the disk.

199
00:07:23,480 --> 00:07:24,910
So I had two executors.

200
00:07:24,910 --> 00:07:25,840
They started running.

201
00:07:25,840 --> 00:07:29,099
Meanwhile, this user started
spamming my application

202
00:07:29,100 --> 00:07:31,930
with all these new comments.

203
00:07:31,930 --> 00:07:33,500
I finished it in the comments.

204
00:07:33,500 --> 00:07:34,440
The other one came.

205
00:07:34,440 --> 00:07:36,480
We put the comment in the disk.

206
00:07:36,480 --> 00:07:38,870
And now we are trying
to send it to servers.

207
00:07:38,870 --> 00:07:40,780
Meanwhile, the
network is really bad.

208
00:07:40,780 --> 00:07:43,640
So the fetch bitmap
job is still running.

209
00:07:43,640 --> 00:07:45,760
The view controller
got the notification

210
00:07:45,760 --> 00:07:48,780
about the new comment and
wanted to refresh itself.

211
00:07:48,780 --> 00:07:52,080
But the queue already is full.

212
00:07:52,080 --> 00:07:52,680
I'm using.

213
00:07:52,680 --> 00:07:55,000
And then the job cannot run.

214
00:07:55,000 --> 00:07:57,010
So the UI is not
updating because I'm

215
00:07:57,010 --> 00:07:58,770
trying to fetch a bitmap.

216
00:07:58,770 --> 00:07:59,370
This is bad.

217
00:07:59,370 --> 00:07:59,870
This is bad.

218
00:07:59,870 --> 00:08:02,210
That means the
priorities are not good.

219
00:08:02,210 --> 00:08:03,430
But it's very hard to know.

220
00:08:03,430 --> 00:08:05,290
You don't know how
long the job will take.

221
00:08:05,290 --> 00:08:07,790
You cannot estimate
it all the time.

222
00:08:07,790 --> 00:08:11,100
But what you can do is
separate these things.

223
00:08:11,100 --> 00:08:14,320
So if I have a different
queue for my network tasks,

224
00:08:14,320 --> 00:08:16,980
and a different queue
for my local tasks,

225
00:08:16,980 --> 00:08:20,080
when my network is
flaky, my application

226
00:08:20,080 --> 00:08:21,229
is still responsive.

227
00:08:21,230 --> 00:08:23,090
Because they are never affected.

228
00:08:23,090 --> 00:08:26,760
So if we're on
the same jobs that

229
00:08:26,760 --> 00:08:29,000
were on the previous
center, as you can see now,

230
00:08:29,000 --> 00:08:32,210
they're going into
different threads.

231
00:08:32,210 --> 00:08:33,809
And the local test
queue just keeps

232
00:08:33,808 --> 00:08:36,319
running because disk fine.

233
00:08:36,320 --> 00:08:38,835
Because we couldn't fetch the
bitmap, we couldn't update.

234
00:08:38,835 --> 00:08:40,460
We couldn't send the
comment to server.

235
00:08:40,460 --> 00:08:44,777
But who cares-- user
is still seeing it.

236
00:08:44,777 --> 00:08:47,850
And if we make the
changes, well, you

237
00:08:47,850 --> 00:08:49,980
see everything is sending.

238
00:08:49,980 --> 00:08:52,860
And as it gets time to
run the server jobs,

239
00:08:52,860 --> 00:08:54,720
we're seeing there
they're starting to turn

240
00:08:54,720 --> 00:08:57,069
black, from top, one by one.

241
00:08:57,069 --> 00:08:58,360
They will eventually be synced.

242
00:08:58,360 --> 00:09:01,370


243
00:09:01,370 --> 00:09:04,370
So one of the feedbacks we
get after [INAUDIBLE] is, OK,

244
00:09:04,370 --> 00:09:06,640
but how does the
activity get notified?

245
00:09:06,640 --> 00:09:10,220
So activity is a very,
very simple state machine

246
00:09:10,220 --> 00:09:11,770
in this scenario.

247
00:09:11,770 --> 00:09:14,319
When it is created,
you set up your UI.

248
00:09:14,320 --> 00:09:16,170
That's all you do.

249
00:09:16,170 --> 00:09:19,050
When you start, you
register for the events

250
00:09:19,050 --> 00:09:20,160
you want to know about.

251
00:09:20,160 --> 00:09:21,969
And you load your data.

252
00:09:21,970 --> 00:09:25,210
This is how it ensures
that between restarts

253
00:09:25,210 --> 00:09:27,302
or whatever, if there
are some events you miss,

254
00:09:27,302 --> 00:09:28,260
you'll never miss them.

255
00:09:28,260 --> 00:09:30,050
Because the onStart,
you register

256
00:09:30,050 --> 00:09:33,040
and you refresh your data.

257
00:09:33,040 --> 00:09:36,584
And when an event comes,
just refresh your data.

258
00:09:36,585 --> 00:09:38,610
It's like the same
thing over and over.

259
00:09:38,610 --> 00:09:41,240
OnStop-- don't
refresh your data.

260
00:09:41,240 --> 00:09:43,170
You just unregister from events.

261
00:09:43,170 --> 00:09:44,880
So your life cycle
is very simple.

262
00:09:44,880 --> 00:09:46,135
Like, this happens, I do this.

263
00:09:46,135 --> 00:09:47,134
This happens, I do this.

264
00:09:47,134 --> 00:09:50,520
This makes it easier to
test, much more stable, much

265
00:09:50,520 --> 00:09:52,980
more easier to understand.

266
00:09:52,980 --> 00:09:54,340
OK, back to you, Adam.

267
00:09:54,340 --> 00:10:00,330
ADAM POWELL: All right, so the
key takeaway from all the demo

268
00:10:00,330 --> 00:10:02,280
that we just saw
there was, really, you

269
00:10:02,280 --> 00:10:04,319
need to design for offline.

270
00:10:04,320 --> 00:10:07,190
Always assume that the
network is not your friend.

271
00:10:07,190 --> 00:10:08,510
It's going to be slow.

272
00:10:08,510 --> 00:10:11,145
And if you want to deliver
a good user experience,

273
00:10:11,145 --> 00:10:13,520
you really can't just blame
the network for why something

274
00:10:13,520 --> 00:10:14,689
isn't popping in quickly.

275
00:10:14,690 --> 00:10:16,170
The table stakes
have really been

276
00:10:16,170 --> 00:10:19,500
raised on this when
it comes to mobile.

277
00:10:19,500 --> 00:10:23,700
So to solve this, back
your UI with a local model

278
00:10:23,700 --> 00:10:25,280
and use your other
application logic

279
00:10:25,280 --> 00:10:27,750
to sync the model and
server rather than doing

280
00:10:27,750 --> 00:10:29,420
this as live API calls.

281
00:10:29,420 --> 00:10:32,540
It can be really tempting to
try to optimize for the case

282
00:10:32,540 --> 00:10:35,343
where you want data freshness
above all else, where you

283
00:10:35,344 --> 00:10:37,260
really don't want to
show anything to the user

284
00:10:37,260 --> 00:10:39,430
unless you're really,
really sure about it.

285
00:10:39,430 --> 00:10:41,160
But this is one of
those things where,

286
00:10:41,160 --> 00:10:44,930
if you assume success
versus assuming failure,

287
00:10:44,930 --> 00:10:48,671
then what types of claims
are you really making

288
00:10:48,672 --> 00:10:50,130
about your software
when you assume

289
00:10:50,130 --> 00:10:52,120
failure in the common case?

290
00:10:52,120 --> 00:10:54,090
I mean, your software
is going to work, right?

291
00:10:54,090 --> 00:10:56,150
Your server is going to
come back with the answer

292
00:10:56,150 --> 00:10:57,620
that you expected, right?

293
00:10:57,620 --> 00:10:58,990
So optimize for those cases.

294
00:10:58,990 --> 00:10:59,850
Predict it.

295
00:10:59,850 --> 00:11:02,149
Show it to the user early.

296
00:11:02,149 --> 00:11:04,190
YIGIT BOYAR: By the way,
I just learned yesterday

297
00:11:04,190 --> 00:11:07,890
there's is a fancy new name
called optimistic rendering.

298
00:11:07,890 --> 00:11:11,290
I feel like now it is
called optimistic rendering.

299
00:11:11,290 --> 00:11:14,429
ADAM POWELL: Yeah,
you see this principle

300
00:11:14,429 --> 00:11:16,720
at work in a lot of other
areas of software development

301
00:11:16,720 --> 00:11:17,220
as well.

302
00:11:17,220 --> 00:11:19,580
Games is one really
prominent example

303
00:11:19,580 --> 00:11:22,720
where a lot of network
latency compensation

304
00:11:22,720 --> 00:11:25,940
systems in multiplayer games
are based on this principle.

305
00:11:25,940 --> 00:11:28,380
They predict based
on what happened

306
00:11:28,380 --> 00:11:31,010
in the previous known
state from the network.

307
00:11:31,010 --> 00:11:35,800
So you can use these same
ideas in your own apps.

308
00:11:35,800 --> 00:11:38,910
So make sure that these
things don't necessarily

309
00:11:38,910 --> 00:11:41,630
depend on each other unless
it's in a very loose fashion.

310
00:11:41,630 --> 00:11:43,040
Use events and
callbacks and such

311
00:11:43,040 --> 00:11:45,382
when needed to notify
other parts of your system

312
00:11:45,382 --> 00:11:46,589
about a state that's changed.

313
00:11:46,590 --> 00:11:50,710


314
00:11:50,710 --> 00:11:53,200
So everybody always asks us
about dependency injection

315
00:11:53,200 --> 00:11:53,820
as well.

316
00:11:53,820 --> 00:11:54,360
Is it good?

317
00:11:54,360 --> 00:11:55,270
Is it bad?

318
00:11:55,270 --> 00:11:56,107
What should I use?

319
00:11:56,107 --> 00:11:57,189
What library should I use?

320
00:11:57,190 --> 00:11:59,130
Well, I mean, use
it if it helps.

321
00:11:59,130 --> 00:12:00,670
Everything has a cost.

322
00:12:00,670 --> 00:12:03,608
So know the side effects of
what it is that you're doing

323
00:12:03,609 --> 00:12:05,150
and what it is that
you're including.

324
00:12:05,150 --> 00:12:07,280
It's very, very easy to
include a new dependency

325
00:12:07,280 --> 00:12:08,310
in your application.

326
00:12:08,310 --> 00:12:10,560
And it's not always easy to
see what the costs of that

327
00:12:10,560 --> 00:12:12,430
are going to be at run time,
especially when you're just

328
00:12:12,430 --> 00:12:13,770
bench testing at your desk.

329
00:12:13,770 --> 00:12:16,228
Everything is in the optimal
case when you're sitting there

330
00:12:16,228 --> 00:12:17,219
at your desk.

331
00:12:17,220 --> 00:12:20,950
So avoid reflection for
better performance as well.

332
00:12:20,950 --> 00:12:22,860
Many dependency
injection frameworks

333
00:12:22,860 --> 00:12:25,550
have a heavy runtime component
versus a compile time

334
00:12:25,550 --> 00:12:26,170
component.

335
00:12:26,170 --> 00:12:28,641
Some systems like Dagger
2 do this at compile time,

336
00:12:28,641 --> 00:12:31,140
and it ends up being much more
optimal for your application.

337
00:12:31,140 --> 00:12:33,530
So take a look into these and
see what the tradeoffs are.

338
00:12:33,530 --> 00:12:36,180


339
00:12:36,180 --> 00:12:39,680
When it comes to networking,
so we talked about other things

340
00:12:39,680 --> 00:12:40,319
that we can do.

341
00:12:40,320 --> 00:12:44,480
Always assume the network
is going to be slow, janky.

342
00:12:44,480 --> 00:12:46,610
Always assume that
you've got your phone

343
00:12:46,610 --> 00:12:48,760
in the middle of a conference
with a crowded Wi-Fi

344
00:12:48,760 --> 00:12:50,930
and completely
slammed cell towers.

345
00:12:50,930 --> 00:12:53,729
That's basically your case that
you want to optimize for here.

346
00:12:53,730 --> 00:12:55,896
Because this is when people
are going to notice that

347
00:12:55,896 --> 00:12:57,920
your application is
broken when it falls over.

348
00:12:57,920 --> 00:13:00,209
So your API design
at the network layer

349
00:13:00,210 --> 00:13:02,540
can actually affect
this as well.

350
00:13:02,540 --> 00:13:05,699
So design your back end for
your client, not the other way

351
00:13:05,700 --> 00:13:06,556
around.

352
00:13:06,556 --> 00:13:09,180
And this is one of those things
that sounds really obvious when

353
00:13:09,180 --> 00:13:10,469
you get up here and say it.

354
00:13:10,470 --> 00:13:13,784
But as you start building server
back ends for these things,

355
00:13:13,784 --> 00:13:15,200
you start exposing
pieces that you

356
00:13:15,200 --> 00:13:16,820
may need, so on and so forth.

357
00:13:16,820 --> 00:13:20,210
And really you start building
it up as a series of layers.

358
00:13:20,210 --> 00:13:22,970
So you have the very
low level components

359
00:13:22,970 --> 00:13:24,804
that provide your data,
such as the network.

360
00:13:24,804 --> 00:13:26,678
And then you have the
higher level components

361
00:13:26,678 --> 00:13:28,010
that provide the presentation.

362
00:13:28,010 --> 00:13:30,830
And it's very tempting to not
have the higher levels inform

363
00:13:30,830 --> 00:13:32,180
the design of the lower levels.

364
00:13:32,180 --> 00:13:35,280
But you can get a lot
of wins by doing this.

365
00:13:35,280 --> 00:13:37,630
Also, process as much
as you can on the server

366
00:13:37,630 --> 00:13:38,590
side to begin with.

367
00:13:38,590 --> 00:13:39,992
You have these
big, beefy servers

368
00:13:39,992 --> 00:13:41,949
in the cloud that can do
a lot of work for you.

369
00:13:41,950 --> 00:13:46,430
Don't offload stuff to the
client that you don't have to.

370
00:13:46,430 --> 00:13:49,430
More specifically, pass
metadata to the client.

371
00:13:49,430 --> 00:13:51,900
This is something that
can really, really improve

372
00:13:51,900 --> 00:13:52,930
your user experience.

373
00:13:52,930 --> 00:13:55,520
If you have a
large blob of data,

374
00:13:55,520 --> 00:13:58,220
such as a big photo, that
you're going to pull down

375
00:13:58,220 --> 00:14:02,330
as part of syncing some sort
of social app, for example,

376
00:14:02,330 --> 00:14:04,230
what do you know about
this image at the time

377
00:14:04,230 --> 00:14:07,640
that you've made this request
and gotten this response back?

378
00:14:07,640 --> 00:14:08,910
Well, not a whole lot.

379
00:14:08,910 --> 00:14:11,285
So what are you going to show
while that loads, while you

380
00:14:11,285 --> 00:14:13,389
actually go fetch that image?

381
00:14:13,389 --> 00:14:15,430
A better case would be to
pass along a little bit

382
00:14:15,430 --> 00:14:16,569
more metadata.

383
00:14:16,570 --> 00:14:19,741
Give your application some
hints that it needs to succeed.

384
00:14:19,741 --> 00:14:21,740
In this case, we're passing
the width and height

385
00:14:21,740 --> 00:14:25,250
of this image in advance before
we go fetch the image itself.

386
00:14:25,250 --> 00:14:28,300
This allows us to perfectly
size a placeholder in our UI

387
00:14:28,300 --> 00:14:31,030
so that you don't have your
UI jumping back and forth

388
00:14:31,030 --> 00:14:32,980
as the user scrolls
through or attempts

389
00:14:32,980 --> 00:14:34,910
to move back and forth.

390
00:14:34,910 --> 00:14:36,910
We've also passed along
some palette information

391
00:14:36,910 --> 00:14:40,100
here just to be able to give
our UI a little bit more

392
00:14:40,100 --> 00:14:43,170
of a splash of color that
keeps the flavor of the image

393
00:14:43,170 --> 00:14:45,180
before we actually
have the real bits.

394
00:14:45,180 --> 00:14:48,250


395
00:14:48,250 --> 00:14:50,021
Battery and data--
this is another concern

396
00:14:50,021 --> 00:14:52,270
that you've got whenever
you're talking to the network

397
00:14:52,270 --> 00:14:53,811
as well, especially
when you're doing

398
00:14:53,811 --> 00:14:55,390
any sort of background syncing.

399
00:14:55,390 --> 00:14:58,120
Batch your requests
as much as possible.

400
00:14:58,120 --> 00:15:00,070
Now, we've provided
a lot of other tools

401
00:15:00,070 --> 00:15:03,420
in recent versions of Android
to help you do this effectively.

402
00:15:03,420 --> 00:15:05,880
Things like Doze and
Marshmallow are great examples.

403
00:15:05,880 --> 00:15:07,970
Doze will do a lot
of this for you.

404
00:15:07,970 --> 00:15:10,930
But really, don't just rely
on that as your sole way

405
00:15:10,930 --> 00:15:11,890
of dealing with this.

406
00:15:11,890 --> 00:15:13,400
Doze is essentially
the last line

407
00:15:13,400 --> 00:15:15,160
of defense for the
user at this point.

408
00:15:15,160 --> 00:15:16,930
Use the job scheduler
when it makes sense.

409
00:15:16,930 --> 00:15:19,130
Give Android as much
information about what

410
00:15:19,130 --> 00:15:21,237
it is that your app is
actually trying to do.

411
00:15:21,237 --> 00:15:22,819
And that way, Android
can make smarter

412
00:15:22,820 --> 00:15:26,870
decisions about how
best to optimize that.

413
00:15:26,870 --> 00:15:30,700
The key takeaway here is
act locally, sync globally.

414
00:15:30,700 --> 00:15:34,100
You really want to give the user
a very fast, very responsive

415
00:15:34,100 --> 00:15:37,100
local experience whenever
they're using your application.

416
00:15:37,100 --> 00:15:39,950
And then make sure that you
keep that in sync with the cloud

417
00:15:39,950 --> 00:15:43,275
almost as an afterthought
compared with the presentation

418
00:15:43,275 --> 00:15:44,400
that you're trying to give.

419
00:15:44,400 --> 00:15:46,797


420
00:15:46,797 --> 00:15:48,380
So no talk of
application architecture

421
00:15:48,380 --> 00:15:49,838
would be complete
without some sort

422
00:15:49,838 --> 00:15:53,319
of addressing of the question
of activities and fragments.

423
00:15:53,320 --> 00:15:56,610
This is something that we
constantly get questions about,

424
00:15:56,610 --> 00:15:57,810
even within Google.

425
00:15:57,810 --> 00:16:00,530
We'll get questions, like, OK,
well, should I use activities

426
00:16:00,530 --> 00:16:02,280
or should I use fragments
to build my app?

427
00:16:02,280 --> 00:16:04,790
It's like, well,
that doesn't entirely

428
00:16:04,790 --> 00:16:07,300
make a whole lot of
sense to question.

429
00:16:07,300 --> 00:16:09,250
Fragments are really
just encapsulated parts

430
00:16:09,250 --> 00:16:09,990
of an activity.

431
00:16:09,990 --> 00:16:13,441
So when you build
up your application,

432
00:16:13,441 --> 00:16:15,190
when your activity
starts getting too big,

433
00:16:15,190 --> 00:16:16,430
and you need to
start breaking it up

434
00:16:16,430 --> 00:16:18,339
so you can still think
about it effectively,

435
00:16:18,340 --> 00:16:20,631
it's a great time to break
it down into some fragments.

436
00:16:20,631 --> 00:16:23,207
Or if you start by building
single fragments that sort

437
00:16:23,207 --> 00:16:25,165
of compose together a
little bit more than that

438
00:16:25,165 --> 00:16:27,309
so that you keep your
concerns separated,

439
00:16:27,309 --> 00:16:29,100
that can help keep
things a little bit more

440
00:16:29,100 --> 00:16:30,475
straight in your
head so that you

441
00:16:30,475 --> 00:16:33,310
don't end up with these
giant activity god classes.

442
00:16:33,310 --> 00:16:35,880
Fragments and views is
another one that we get a lot.

443
00:16:35,880 --> 00:16:37,590
Now, this is
something that we talk

444
00:16:37,590 --> 00:16:39,360
about quite a bit on
the framework team

445
00:16:39,360 --> 00:16:41,890
in terms of, one of
the almost regrets

446
00:16:41,890 --> 00:16:43,710
of the fragment
API at this point

447
00:16:43,710 --> 00:16:46,130
is that you've got this handy
little tag that you can just

448
00:16:46,130 --> 00:16:48,070
stick in your layout that
says, fragment, and says,

449
00:16:48,070 --> 00:16:49,400
go ahead and
instantiate a fragment

450
00:16:49,400 --> 00:16:51,699
and stick it right here in
my layout when I inflate it.

451
00:16:51,700 --> 00:16:53,533
And this thing is really,
really convenient.

452
00:16:53,533 --> 00:16:55,430
It makes for great code
examples and demos,

453
00:16:55,430 --> 00:16:58,300
because you can do things
like have a layout that sticks

454
00:16:58,300 --> 00:16:59,630
two fragments side by side.

455
00:16:59,630 --> 00:17:02,820
And then you rotate the
device, and it sticks them

456
00:17:02,820 --> 00:17:04,252
stacked on top of one another.

457
00:17:04,252 --> 00:17:05,210
And you say, hey, look.

458
00:17:05,210 --> 00:17:07,430
Look at this great decoupled
system that I've got.

459
00:17:07,430 --> 00:17:10,329
It makes for fantastic demo.

460
00:17:10,329 --> 00:17:12,139
But realistically,
this makes people

461
00:17:12,140 --> 00:17:15,510
think of fragments as being
view constructs themselves.

462
00:17:15,510 --> 00:17:16,980
And really, they kind of aren't.

463
00:17:16,980 --> 00:17:19,839
So they live in these
very different worlds.

464
00:17:19,839 --> 00:17:22,310
So views are really the
nuts and bolts of your UIs

465
00:17:22,310 --> 00:17:24,929
that you're building, whereas
activities and fragments are

466
00:17:24,930 --> 00:17:27,069
the lifecycle constructs
that basically provide

467
00:17:27,069 --> 00:17:30,710
the plug-in points of contact
with the rest of the system

468
00:17:30,710 --> 00:17:33,880
that tells you what's going on.

469
00:17:33,880 --> 00:17:35,740
So many times,
you're going to want

470
00:17:35,740 --> 00:17:38,560
to use both to keep these
responsibilities clear.

471
00:17:38,560 --> 00:17:40,700
Just as Yigit mentioned
earlier, you're

472
00:17:40,700 --> 00:17:43,560
going to want to use
these signals that you

473
00:17:43,560 --> 00:17:46,990
get from your activity and,
in conjunction with that,

474
00:17:46,990 --> 00:17:50,560
through your fragments as
well, if you're using those,

475
00:17:50,560 --> 00:17:53,389
to basically inform when you
should register, unregister

476
00:17:53,390 --> 00:17:56,420
for events, so on and so forth.

477
00:17:56,420 --> 00:17:58,920
But the views should really be
their own encapsulated pieces

478
00:17:58,920 --> 00:18:00,503
separate from that
that are controlled

479
00:18:00,503 --> 00:18:01,629
by these other constructs.

480
00:18:01,630 --> 00:18:04,320


481
00:18:04,320 --> 00:18:07,550
OK, so moving along to another
topic of contention often--

482
00:18:07,550 --> 00:18:09,280
memory.

483
00:18:09,280 --> 00:18:11,330
So this is something
that we talk about a lot.

484
00:18:11,330 --> 00:18:13,199
If you've watched
any of Colt's talks

485
00:18:13,200 --> 00:18:14,840
on the Android
performance practices,

486
00:18:14,840 --> 00:18:16,639
you've seen some of these.

487
00:18:16,640 --> 00:18:19,090
Avoid allocating objects
in hot code paths.

488
00:18:19,090 --> 00:18:21,300
Putting pressure on
the GC is not so great.

489
00:18:21,300 --> 00:18:23,210
Art is a lot better
at this these days

490
00:18:23,210 --> 00:18:25,670
than Android used to
be at all of this.

491
00:18:25,670 --> 00:18:28,050
But there's still a lot of
those devices out in the wild.

492
00:18:28,050 --> 00:18:31,220
And if you watch this in a
few sensitive code paths,

493
00:18:31,220 --> 00:18:33,200
then you're going to
end up with a little bit

494
00:18:33,200 --> 00:18:34,300
of a smoother experience.

495
00:18:34,300 --> 00:18:35,883
So you can pool and
reuse some objects

496
00:18:35,883 --> 00:18:37,160
when you measure a problem.

497
00:18:37,160 --> 00:18:38,910
That last part is
really the key--

498
00:18:38,910 --> 00:18:40,064
when you measure a problem.

499
00:18:40,064 --> 00:18:42,480
Make sure that you're measuring
these things before you go

500
00:18:42,480 --> 00:18:45,150
and contort the
internals of your system.

501
00:18:45,150 --> 00:18:48,036
And these are the sorts of
things where, some things, you

502
00:18:48,036 --> 00:18:49,660
can make some decisions
early that will

503
00:18:49,660 --> 00:18:52,260
help you move into
these optimizations

504
00:18:52,260 --> 00:18:53,410
should you need them.

505
00:18:53,410 --> 00:18:55,659
And some things, it
really doesn't matter.

506
00:18:55,659 --> 00:18:57,700
So write the code the way
that it's clearer first

507
00:18:57,700 --> 00:18:59,630
and then optimize later.

508
00:18:59,630 --> 00:19:01,721
So GC still kind of
remains your enemy,

509
00:19:01,721 --> 00:19:03,470
especially on some of
these older devices,

510
00:19:03,470 --> 00:19:05,886
even as the garbage collector
in Android gets much better.

511
00:19:05,886 --> 00:19:09,195


512
00:19:09,195 --> 00:19:13,110
So a perfect example of how
this may affect your API design

513
00:19:13,110 --> 00:19:15,756
internally-- just with
smaller components.

514
00:19:15,757 --> 00:19:18,090
Now, what's the difference
between these two approaches?

515
00:19:18,090 --> 00:19:22,610
Well, the top one is arguably
more idiomatic, much cleaner.

516
00:19:22,610 --> 00:19:25,459
You can make some assumptions
about it in terms of, OK, well,

517
00:19:25,460 --> 00:19:27,980
the object it returns
is hopefully safe

518
00:19:27,980 --> 00:19:29,950
if that's a mutable
object to begin with.

519
00:19:29,950 --> 00:19:32,250
But in order for
that to be true, then

520
00:19:32,250 --> 00:19:34,890
this getter has to be
allocating a new rect for me

521
00:19:34,890 --> 00:19:35,870
that it returns.

522
00:19:35,870 --> 00:19:37,780
Well, now we've got allocation.

523
00:19:37,780 --> 00:19:40,480
So where do you
end up using that?

524
00:19:40,480 --> 00:19:43,970
Versus the second form here,
which is basically just taking

525
00:19:43,970 --> 00:19:46,694
an input parameter that the
method is going to fill out.

526
00:19:46,694 --> 00:19:48,110
You know that the
second one isn't

527
00:19:48,110 --> 00:19:51,081
going to perform any additional
allocation in this case.

528
00:19:51,082 --> 00:19:52,790
This is the sort of
thing that you really

529
00:19:52,790 --> 00:19:55,129
only want to worry about in
extremely hot code paths.

530
00:19:55,130 --> 00:19:58,010
We're talking layout that
gets run many, many times.

531
00:19:58,010 --> 00:20:01,022
We're talking drawing that
gets run 60 times per second.

532
00:20:01,022 --> 00:20:02,480
If you're talking
about things that

533
00:20:02,480 --> 00:20:04,104
happen in terms of
your event handlers,

534
00:20:04,104 --> 00:20:05,970
like clicks, and so
on, and so forth,

535
00:20:05,970 --> 00:20:08,160
you really don't need to
be contorting your system

536
00:20:08,160 --> 00:20:09,040
this much internally.

537
00:20:09,040 --> 00:20:12,090


538
00:20:12,090 --> 00:20:15,179
But for that very small
percentage of your code,

539
00:20:15,180 --> 00:20:18,170
it is OK to write ugly code
if it helps your users.

540
00:20:18,170 --> 00:20:19,920
Your users are not
going to see your code.

541
00:20:19,920 --> 00:20:21,760
They're going to see your UI.

542
00:20:21,760 --> 00:20:24,879
If your UI is ugly because
it's behaving badly,

543
00:20:24,880 --> 00:20:26,520
then that's something
that they do see.

544
00:20:26,520 --> 00:20:30,570
That's something that really
does affect their experience.

545
00:20:30,570 --> 00:20:34,450
The performance critical code
really isn't the majority.

546
00:20:34,450 --> 00:20:37,040
And, well, all compiled code
looks ugly eventually anyways.

547
00:20:37,040 --> 00:20:40,030


548
00:20:40,030 --> 00:20:42,320
So with that, we're
going to move over

549
00:20:42,320 --> 00:20:44,870
to another demo that kind of
brings a bunch of these ideas

550
00:20:44,870 --> 00:20:45,419
together.

551
00:20:45,420 --> 00:20:47,910
YIGIT BOYAR: OK, so
after the I/O talk,

552
00:20:47,910 --> 00:20:51,610
one of the feedbacks we received
was, OK, talk these things,

553
00:20:51,610 --> 00:20:54,570
but show me some code.

554
00:20:54,570 --> 00:20:56,929
So this time, we wrote
this sample application.

555
00:20:56,930 --> 00:20:59,240
Keep in mind, this is
a sample implication.

556
00:20:59,240 --> 00:21:01,910
And the main focus
here is, how do you

557
00:21:01,910 --> 00:21:04,450
look at this problem more as
a synchronization problem?

558
00:21:04,450 --> 00:21:06,970
How do you design an
application to work offline?

559
00:21:06,970 --> 00:21:10,080
And we are going to
release the source code.

560
00:21:10,080 --> 00:21:13,250
I'm just waiting
for some approvals.

561
00:21:13,250 --> 00:21:14,520
So here's my application.

562
00:21:14,520 --> 00:21:17,550
I just lost my Chrome.

563
00:21:17,550 --> 00:21:18,070
All right.

564
00:21:18,070 --> 00:21:19,320
Let's come here.

565
00:21:19,320 --> 00:21:20,570
So it's a real app.

566
00:21:20,570 --> 00:21:22,649
There is a real server
running on my computer

567
00:21:22,650 --> 00:21:25,680
just for the
purpose of the demo.

568
00:21:25,680 --> 00:21:29,780
And the application is
just a list of posts.

569
00:21:29,780 --> 00:21:31,310
Hello, everybody, I can say.

570
00:21:31,310 --> 00:21:33,050
I can say, everybody.

571
00:21:33,050 --> 00:21:36,659


572
00:21:36,660 --> 00:21:37,870
So how does this work?

573
00:21:37,870 --> 00:21:40,110
So let's do something dangerous.

574
00:21:40,110 --> 00:21:42,490
And it's not that dangerous.

575
00:21:42,490 --> 00:21:45,060
I'll do more dangerous
things later.

576
00:21:45,060 --> 00:21:47,629
So I just disabled the network.

577
00:21:47,630 --> 00:21:51,640
And I send one more.

578
00:21:51,640 --> 00:21:55,370
So right now, please
forgive my UI.

579
00:21:55,370 --> 00:21:59,004
So there is an upload club
on the right bottom of text

580
00:21:59,005 --> 00:22:03,540
that tells the user, this is
not the same as other ones.

581
00:22:03,540 --> 00:22:05,080
It's almost going to send.

582
00:22:05,080 --> 00:22:07,189
It's not there yet,
so if I actually

583
00:22:07,190 --> 00:22:08,342
look at my real server.

584
00:22:08,342 --> 00:22:14,410
And my application, when
the network recovers,

585
00:22:14,410 --> 00:22:16,030
it will eventually post it.

586
00:22:16,030 --> 00:22:18,600
And it's going to update the UI.

587
00:22:18,600 --> 00:22:21,745
Now, with some other examples
we saw in the previous time--

588
00:22:21,745 --> 00:22:23,770
actually, we can
crash the server, too.

589
00:22:23,770 --> 00:22:25,566
So now the server is
not running anymore.

590
00:22:25,566 --> 00:22:29,560


591
00:22:29,560 --> 00:22:33,270
So for this demo, I have a
very simple back off time.

592
00:22:33,270 --> 00:22:36,057
But it'll try back off.

593
00:22:36,057 --> 00:22:37,640
ADAM POWELL: I mean,
it does cry, too.

594
00:22:37,640 --> 00:22:38,800
YIGIT BOYAR: These are
my application-- yeah,

595
00:22:38,800 --> 00:22:39,780
it does cry too.

596
00:22:39,780 --> 00:22:41,537
These are my
application logs here.

597
00:22:41,537 --> 00:22:44,120
It actually keeps trying to post
it, because there is network.

598
00:22:44,120 --> 00:22:46,300
It's just the
server is crashing.

599
00:22:46,300 --> 00:22:51,870
And now I finally bring
the server up-- oops,

600
00:22:51,870 --> 00:22:55,929
not like that, not like that.

601
00:22:55,930 --> 00:22:59,860
OK, so it started backing off.

602
00:22:59,860 --> 00:23:02,097
It will eventually send
the comment to the server.

603
00:23:02,097 --> 00:23:02,680
It Dies there.

604
00:23:02,680 --> 00:23:04,250
It keeps retrying.

605
00:23:04,250 --> 00:23:06,060
And yes, it did send.

606
00:23:06,060 --> 00:23:11,298
So let's do one more case where
we do crash the server again.

607
00:23:11,298 --> 00:23:15,190


608
00:23:15,190 --> 00:23:17,950
OK, one more comment--
it's the same.

609
00:23:17,950 --> 00:23:19,840
Oh wait, it didn't crash.

610
00:23:19,840 --> 00:23:21,205
Sorry, I crashed the logger.

611
00:23:21,205 --> 00:23:24,530


612
00:23:24,530 --> 00:23:26,750
So we crashed the
server this time.

613
00:23:26,750 --> 00:23:28,150
See, the application works.

614
00:23:28,150 --> 00:23:30,420
ADAM POWELL: You wrote a server
that doesn't even crash right.

615
00:23:30,420 --> 00:23:31,670
Come on, what do we have here?

616
00:23:31,670 --> 00:23:34,165


617
00:23:34,165 --> 00:23:36,540
YIGIT BOYAR: It should crash
for the purpose of the demo.

618
00:23:36,540 --> 00:23:38,490
I hope your servers won't crash.

619
00:23:38,490 --> 00:23:39,910
So I sent one more comment.

620
00:23:39,910 --> 00:23:43,510
And then I simply go out.

621
00:23:43,510 --> 00:23:45,310
So my emulator
may crash, though.

622
00:23:45,310 --> 00:23:47,629
It's been having some problems.

623
00:23:47,630 --> 00:23:49,340
I did go out.

624
00:23:49,340 --> 00:23:52,439
And I am going to
kill that application.

625
00:23:52,440 --> 00:23:53,210
I come back.

626
00:23:53,210 --> 00:23:57,180


627
00:23:57,180 --> 00:23:59,910
OK, so the comment
is still there.

628
00:23:59,910 --> 00:24:02,410
It cannot update the feed, but
the comment is waiting for me

629
00:24:02,410 --> 00:24:03,390
there.

630
00:24:03,390 --> 00:24:05,165
And I will just run the server.

631
00:24:05,165 --> 00:24:06,889
The screen does
eventually synchronise.

632
00:24:06,890 --> 00:24:09,680
So the idea is the
application doesn't care

633
00:24:09,680 --> 00:24:10,860
about when the comment goes.

634
00:24:10,860 --> 00:24:13,649
It's staying in the disk
waiting to be uploaded.

635
00:24:13,650 --> 00:24:16,440
There is some other job that's
taking care of the upload.

636
00:24:16,440 --> 00:24:18,690
But it will eventually
go to server,

637
00:24:18,690 --> 00:24:21,170
unless I have a bug, of course.

638
00:24:21,170 --> 00:24:25,508
So how do we take
care of these things?

639
00:24:25,508 --> 00:24:29,030


640
00:24:29,030 --> 00:24:34,329
The way it works is we
have this feed activity.

641
00:24:34,329 --> 00:24:36,245
By the way, again, this
is a demo application.

642
00:24:36,245 --> 00:24:37,828
I'm trying to focus
on certain things.

643
00:24:37,828 --> 00:24:41,010
There might be toerh problems
with this demo application.

644
00:24:41,010 --> 00:24:44,160
The important take away is the
thing we're focusing on here.

645
00:24:44,160 --> 00:24:47,650
So this application,
when you call Send Post,

646
00:24:47,650 --> 00:24:51,280
it simply tells the feed
controller to send the post.

647
00:24:51,280 --> 00:24:54,040
Which, as the job to
the disk-- there's

648
00:24:54,040 --> 00:24:56,770
something persistent
that will eventually run,

649
00:24:56,770 --> 00:24:58,810
which is responsible
to update the disk,

650
00:24:58,810 --> 00:25:01,820
as well as sending the post.

651
00:25:01,820 --> 00:25:03,590
So it updates the disk.

652
00:25:03,590 --> 00:25:05,480
And then this
[? pitches ?] an event.

653
00:25:05,480 --> 00:25:08,020
When this event is
this page, my activity

654
00:25:08,020 --> 00:25:10,930
knows about this event,
refreshes itself.

655
00:25:10,930 --> 00:25:13,710
When it runs, it
does the same thing.

656
00:25:13,710 --> 00:25:15,839
Or when it's cancelled,
it does the same thing.

657
00:25:15,839 --> 00:25:16,879
This is a persistent job.

658
00:25:16,880 --> 00:25:19,800
That means it's going
to be saved in the disk

659
00:25:19,800 --> 00:25:23,580
until it succeeds or
reaches the retry limit.

660
00:25:23,580 --> 00:25:24,580
They say, OK, all right.

661
00:25:24,580 --> 00:25:26,780
The comment is posted-- nice.

662
00:25:26,780 --> 00:25:29,230
And so another problem
about synchronization--

663
00:25:29,230 --> 00:25:33,050
what happens if I'm offline?

664
00:25:33,050 --> 00:25:33,774
Send comments.

665
00:25:33,775 --> 00:25:36,890


666
00:25:36,890 --> 00:25:39,790
So it's not working, eventually.

667
00:25:39,790 --> 00:25:43,139
And I go to this website.

668
00:25:43,140 --> 00:25:44,800
And I create a comment here.

669
00:25:44,800 --> 00:25:45,919
I'm from the web.

670
00:25:45,920 --> 00:25:53,450


671
00:25:53,450 --> 00:25:57,210
So now these two states
are inconsistent.

672
00:25:57,210 --> 00:25:59,960
My client doesn't know
about the new one.

673
00:25:59,960 --> 00:26:02,400
And I have a comment locally.

674
00:26:02,400 --> 00:26:04,270
So if I enable my
network-- by the way,

675
00:26:04,270 --> 00:26:06,220
normally, when the
network comes back,

676
00:26:06,220 --> 00:26:07,830
you would refresh your feed.

677
00:26:07,830 --> 00:26:10,679
But I'm not doing it for
the purpose of the demo.

678
00:26:10,680 --> 00:26:12,250
So when the network
comes back, it's

679
00:26:12,250 --> 00:26:15,190
going to send the
post instantly.

680
00:26:15,190 --> 00:26:16,740
So it's out of sync.

681
00:26:16,740 --> 00:26:18,573
But when I eventually
refresh, it's

682
00:26:18,573 --> 00:26:20,760
going to add anyone
to the correct order.

683
00:26:20,760 --> 00:26:23,600
This is because everything is
time stamped by the server.

684
00:26:23,600 --> 00:26:27,909
So until a post is
sent to the server,

685
00:26:27,910 --> 00:26:30,400
you make a best guess
time stamp on it.

686
00:26:30,400 --> 00:26:33,870
So for this example, the
way I do it is-- again,

687
00:26:33,870 --> 00:26:36,199
it may change per
your application.

688
00:26:36,200 --> 00:26:39,925
But the way this
one does is-- wait,

689
00:26:39,925 --> 00:26:41,050
let me open the [? safe ?].

690
00:26:41,050 --> 00:26:43,720


691
00:26:43,720 --> 00:26:46,440
OK, so when it
creates, it actually

692
00:26:46,440 --> 00:26:51,630
creates the model to get
the best time stamp I have.

693
00:26:51,630 --> 00:26:55,140
This is a way to synchronize
if my client's time is, really,

694
00:26:55,140 --> 00:26:56,190
really off.

695
00:26:56,190 --> 00:26:59,810
And if the new comment is not on
top, that may look really bad.

696
00:26:59,810 --> 00:27:03,000
Because it changed your server
ordering, your UI ordering.

697
00:27:03,000 --> 00:27:04,850
But that may cause problems.

698
00:27:04,850 --> 00:27:10,580
So what I do here is I assign
a best case time stamp locally.

699
00:27:10,580 --> 00:27:12,313
And then we do it
on later on server.

700
00:27:12,314 --> 00:27:16,140


701
00:27:16,140 --> 00:27:18,490
So we get the network again.

702
00:27:18,490 --> 00:27:21,840
And again, like another case,
because of the persistence,

703
00:27:21,840 --> 00:27:25,850
so I send the post here,
click on the usernames,

704
00:27:25,850 --> 00:27:27,730
moves it to the user's post.

705
00:27:27,730 --> 00:27:28,500
And it's done.

706
00:27:28,500 --> 00:27:31,154
I never fetched this user feed.

707
00:27:31,154 --> 00:27:32,070
But the post is there.

708
00:27:32,070 --> 00:27:33,485
It's everywhere
in my application.

709
00:27:33,486 --> 00:27:34,510
Because it's on my disk.

710
00:27:34,510 --> 00:27:36,710
I don't care if it
is not synced or not.

711
00:27:36,710 --> 00:27:38,340
I have a proper model
for that object.

712
00:27:38,340 --> 00:27:40,240
It's a simple value object.

713
00:27:40,240 --> 00:27:42,660
But it's always working.

714
00:27:42,660 --> 00:27:45,360
And let's say, I'm
in the user feed,

715
00:27:45,360 --> 00:27:46,679
but then recover the network.

716
00:27:46,680 --> 00:27:49,310


717
00:27:49,310 --> 00:27:50,340
It will eventually send.

718
00:27:50,340 --> 00:27:51,939
And the feed will update, too.

719
00:27:51,940 --> 00:27:55,070
If I go back, it's already
updated here instantly.

720
00:27:55,070 --> 00:27:58,570
This is because if a UI is
interested in a certain event,

721
00:27:58,570 --> 00:27:59,899
it listens for it.

722
00:27:59,900 --> 00:28:03,872
Now, I'm using a
global event bus here.

723
00:28:03,872 --> 00:28:05,580
You can probably
implement the same thing

724
00:28:05,580 --> 00:28:07,906
with RX or Broadcase.

725
00:28:07,906 --> 00:28:10,030
This is a sample application
that does it this way,

726
00:28:10,030 --> 00:28:11,300
and it works.

727
00:28:11,300 --> 00:28:12,800
There might be
multiple ways to do

728
00:28:12,800 --> 00:28:16,330
the same thing, the right
thing, or maybe a better way.

729
00:28:16,330 --> 00:28:17,600
So we'll get more fancy.

730
00:28:17,600 --> 00:28:21,379
OK, what if the
server is crashing?

731
00:28:21,380 --> 00:28:23,150
So this is my real
server, by the way.

732
00:28:23,150 --> 00:28:24,125
It's a lot of fun.

733
00:28:24,125 --> 00:28:26,840
It's a magical language.

734
00:28:26,840 --> 00:28:30,240
So I'm going to
turn on a flag here.

735
00:28:30,240 --> 00:28:34,320
What this will do is the server
is going to save the post,

736
00:28:34,320 --> 00:28:36,730
but it's going to
crash afterwards.

737
00:28:36,730 --> 00:28:39,800
So I won't be able
to realize that I

738
00:28:39,800 --> 00:28:42,970
could synchronize that post.

739
00:28:42,970 --> 00:28:45,060
So the server is crashing now.

740
00:28:45,060 --> 00:28:47,250
I go back here.

741
00:28:47,250 --> 00:28:49,750
I can say, OK, [INAUDIBLE].

742
00:28:49,750 --> 00:28:52,470
So the job tries 20 times.

743
00:28:52,470 --> 00:28:56,420
And it backs off 250
milliseconds exponentially.

744
00:28:56,420 --> 00:28:59,280
So if will keep trying,
trying, trying, try me again.

745
00:28:59,280 --> 00:29:03,520


746
00:29:03,520 --> 00:29:08,230
So now the server is crashing,
as you can see the crash logs.

747
00:29:08,230 --> 00:29:10,110
It saved the post to the disk.

748
00:29:10,110 --> 00:29:11,310
But the client doesn't know.

749
00:29:11,310 --> 00:29:13,179
So the client keeps retrying.

750
00:29:13,180 --> 00:29:16,410
But what happens is
that your fetch feeds

751
00:29:16,410 --> 00:29:18,220
post endpoint is working fine.

752
00:29:18,220 --> 00:29:20,130
So you refresh.

753
00:29:20,130 --> 00:29:21,590
So the post came back.

754
00:29:21,590 --> 00:29:22,929
I know it's the same post.

755
00:29:22,930 --> 00:29:24,430
So how do I know
it's the same post?

756
00:29:24,430 --> 00:29:26,900
This comes into a
little bit API design.

757
00:29:26,900 --> 00:29:29,240
But we want to do a full demo.

758
00:29:29,240 --> 00:29:31,860
So I did figure out it's the
same post and updated it.

759
00:29:31,860 --> 00:29:36,340
Although my sent posts
have never succeeded.

760
00:29:36,340 --> 00:29:38,419
So the way it works
in this application

761
00:29:38,420 --> 00:29:44,650
is, by design, each element
is assigned a client ID.

762
00:29:44,650 --> 00:29:47,614
So if you look at these examples
here-- are they visible?

763
00:29:47,614 --> 00:29:50,980
Yeah, all right, so
there's a user ID.

764
00:29:50,980 --> 00:29:52,350
And there's also a client ID.

765
00:29:52,350 --> 00:29:55,219
This client ID is
randomly generated

766
00:29:55,220 --> 00:29:58,530
a unique per user per post.

767
00:29:58,530 --> 00:30:00,720
So there is a unique
key in my [INAUDIBLE].

768
00:30:00,720 --> 00:30:02,270
It says user ID and client ID.

769
00:30:02,270 --> 00:30:03,690
It's a unique tuple.

770
00:30:03,690 --> 00:30:07,150
You rely on the fact that
it's not going to conflict.

771
00:30:07,150 --> 00:30:09,220
I mean, technically it can.

772
00:30:09,220 --> 00:30:10,900
Probably it won't.

773
00:30:10,900 --> 00:30:15,150
So by doing this, when I receive
the post from the server,

774
00:30:15,150 --> 00:30:17,320
I know the post already
exists in my disk.

775
00:30:17,320 --> 00:30:20,347
And I update that one, saying
that, OK, I sync this one.

776
00:30:20,347 --> 00:30:21,930
I don't know what
happened to the job.

777
00:30:21,930 --> 00:30:22,800
I don't care.

778
00:30:22,800 --> 00:30:25,220
And then the job
knows while running.

779
00:30:25,220 --> 00:30:28,780
Before trying to send
the post, it checks, hey,

780
00:30:28,780 --> 00:30:30,300
is this already synced?

781
00:30:30,300 --> 00:30:35,330
So here, if you can see the
code here, it just loads it.

782
00:30:35,330 --> 00:30:37,080
And if it's already
synchronized,

783
00:30:37,080 --> 00:30:38,139
it doesn't do anything.

784
00:30:38,140 --> 00:30:39,880
Oh, hey, this has been updated.

785
00:30:39,880 --> 00:30:40,380
Good news.

786
00:30:40,380 --> 00:30:41,760
Everything is working fine.

787
00:30:41,760 --> 00:30:44,700


788
00:30:44,700 --> 00:30:50,450
So one more thing--
OK, so the last idea

789
00:30:50,450 --> 00:30:56,680
here is that this works because
we look at the problem as two

790
00:30:56,680 --> 00:30:57,610
separate problems.

791
00:30:57,610 --> 00:30:59,290
One of them is
only responsible--

792
00:30:59,290 --> 00:31:02,970
take the user interaction,
process the model locally.

793
00:31:02,970 --> 00:31:05,920
And the other one is responsible
to synchronize with the server

794
00:31:05,920 --> 00:31:06,942
however it does.

795
00:31:06,942 --> 00:31:07,650
It's not trivial.

796
00:31:07,650 --> 00:31:10,700
You're writing a bunch of
additional code to say,

797
00:31:10,700 --> 00:31:13,420
local client IDs have
to handle conflicts.

798
00:31:13,420 --> 00:31:15,170
But it works.

799
00:31:15,170 --> 00:31:17,310
So let's look at
one more demo here.

800
00:31:17,310 --> 00:31:21,210
This time, I will
shut down the server.

801
00:31:21,210 --> 00:31:23,770
So I'm sending-- I'm
again that excited kid.

802
00:31:23,770 --> 00:31:25,740
I keep sending all
these messages.

803
00:31:25,740 --> 00:31:28,000
Of course, they're
not going to go.

804
00:31:28,000 --> 00:31:31,720
If I look at here,
they're not going.

805
00:31:31,720 --> 00:31:36,800
When I recover the server, now
the first job is backing off.

806
00:31:36,800 --> 00:31:37,909
It will eventually finish.

807
00:31:37,910 --> 00:31:39,450
Meanwhile, I can send more.

808
00:31:39,450 --> 00:31:42,100


809
00:31:42,100 --> 00:31:44,550
As you can see, they are going
out one by one, one by one,

810
00:31:44,550 --> 00:31:47,909
in the correct order--
my scroll position lost.

811
00:31:47,910 --> 00:31:50,170
This works because
these jobs are

812
00:31:50,170 --> 00:31:52,460
running through the
same queue per pause.

813
00:31:52,460 --> 00:31:56,230
So I know that whoever came
first will be handled first.

814
00:31:56,230 --> 00:31:58,920
So we guarantee that
they are in order.

815
00:31:58,920 --> 00:32:00,670
We cannot guarantee
they are time stamped.

816
00:32:00,670 --> 00:32:03,150
Because that's
technically not possible

817
00:32:03,150 --> 00:32:06,400
unless you want to rely on
what your client timestamp is.

818
00:32:06,400 --> 00:32:09,870
But we granted their order.

819
00:32:09,870 --> 00:32:11,639
Again, this is all
independent of the UI.

820
00:32:11,640 --> 00:32:12,770
It doesn't care at all.

821
00:32:12,770 --> 00:32:16,120
The only thing it knows is, how
do I load this from the disk,

822
00:32:16,120 --> 00:32:19,770
and how do I send these comments
to my application logic?

823
00:32:19,770 --> 00:32:21,830
One more example I
want to go-- actually I

824
00:32:21,830 --> 00:32:23,210
want to go through this code.

825
00:32:23,210 --> 00:32:25,626
So one of the problems with
this event-driven architecture

826
00:32:25,626 --> 00:32:28,205
is since all these
events are happening,

827
00:32:28,205 --> 00:32:29,080
how do I synchronize?

828
00:32:29,080 --> 00:32:31,460
What if I miss an event?

829
00:32:31,460 --> 00:32:34,500
Or what if the timeline's
timestamps don't match?

830
00:32:34,500 --> 00:32:36,690
Again, for this
demo application,

831
00:32:36,690 --> 00:32:40,610
the way this one works is every
single event that is important

832
00:32:40,610 --> 00:32:41,810
comes with a timestamp.

833
00:32:41,810 --> 00:32:44,389
So for example, for
fetching a feed event,

834
00:32:44,390 --> 00:32:47,500
timestamp is the timestamp
of the oldest post.

835
00:32:47,500 --> 00:32:50,490
So if someone is going
to load those once,

836
00:32:50,490 --> 00:32:53,210
it makes sure it includes
that timestamp in the query.

837
00:32:53,210 --> 00:32:55,430
So it loads things
afterwards, that.

838
00:32:55,430 --> 00:32:59,730
So every time the feed
activity receives an event--

839
00:32:59,730 --> 00:33:05,600
let's say [INAUDIBLE]-- it
checks if this is for my user.

840
00:33:05,600 --> 00:33:07,840
And if this is for
my user, it just

841
00:33:07,840 --> 00:33:09,669
calls the refresh
with the oldest one.

842
00:33:09,670 --> 00:33:12,910
And then that refresh method,
while querying the model,

843
00:33:12,910 --> 00:33:14,150
it uses that timestamp.

844
00:33:14,150 --> 00:33:17,240
Or if there's no
timestamp, it uses top one.

845
00:33:17,240 --> 00:33:19,310
Because you don't want to
keep refreshing things.

846
00:33:19,310 --> 00:33:22,169


847
00:33:22,170 --> 00:33:25,285
Yeah, that is, mostly-- let
me see if I miss anything.

848
00:33:25,285 --> 00:33:30,070


849
00:33:30,070 --> 00:33:33,879
OK, I think we are going
to publish this code, both

850
00:33:33,880 --> 00:33:36,890
the server side and
the client side,

851
00:33:36,890 --> 00:33:39,640
to Github as soon as-- I
needed some clarification here

852
00:33:39,640 --> 00:33:40,500
and there.

853
00:33:40,500 --> 00:33:43,195
But you can play with it.

854
00:33:43,195 --> 00:33:44,570
We'll be happy to
get [INAUDIBLE]

855
00:33:44,570 --> 00:33:48,356
or whatever if you think
something could be done better.

856
00:33:48,356 --> 00:33:51,812
And it's nice to share and
just move on from there.

857
00:33:51,812 --> 00:33:55,169
All right, sure, that's it.

858
00:33:55,170 --> 00:33:57,452
It's time for some questions.

859
00:33:57,452 --> 00:34:00,383
[APPLAUSE]

860
00:34:00,383 --> 00:34:06,955


861
00:34:06,955 --> 00:34:09,330
ADAM POWELL: I think that
we've got a microphone floating

862
00:34:09,330 --> 00:34:10,610
around perhaps.

863
00:34:10,610 --> 00:34:13,110
There we go.

864
00:34:13,110 --> 00:34:16,570
AUDIENCE: Will it contain tests?

865
00:34:16,570 --> 00:34:17,400
YIGIT BOYAR: Huh?

866
00:34:17,400 --> 00:34:19,670
AUDIENCE: Will the
project contain tests?

867
00:34:19,670 --> 00:34:23,420
YIGIT BOYAR: Yes,
it actually does.

868
00:34:23,420 --> 00:34:25,199
So actually, I should
have showed it.

869
00:34:25,199 --> 00:34:30,750
So if you look at-- well,
they may not be great tests.

870
00:34:30,750 --> 00:34:32,159
I am not a testing expert.

871
00:34:32,159 --> 00:34:34,092
But they do test.

872
00:34:34,092 --> 00:34:35,550
They're mostly
interrogation tests.

873
00:34:35,550 --> 00:34:38,380
If you look at something more
fancy, for example, fetching

874
00:34:38,380 --> 00:34:41,723
the feed, so I say we do--

875
00:34:41,723 --> 00:34:43,639
ADAM POWELL: Can we
switch the slide back over

876
00:34:43,639 --> 00:34:44,837
to the computer real quick?

877
00:34:44,837 --> 00:34:47,498
YIGIT BOYAR: Oh, sorry.

878
00:34:47,498 --> 00:34:48,789
Can we go back to the computer?

879
00:34:48,789 --> 00:34:51,489


880
00:34:51,489 --> 00:34:53,199
OK, thank you.

881
00:34:53,199 --> 00:34:56,634
So the application uses Dagger.

882
00:34:56,634 --> 00:35:00,822
This is how I marked
some of the API calls.

883
00:35:00,822 --> 00:35:04,580
But let's see-- fetch
feed, no, send comment.

884
00:35:04,580 --> 00:35:05,422
That will be nice.

885
00:35:05,422 --> 00:35:09,070


886
00:35:09,070 --> 00:35:11,035
ADAM POWELL: So
short answer, yes.

887
00:35:11,035 --> 00:35:12,160
YIGIT BOYAR: They are here.

888
00:35:12,160 --> 00:35:13,283
I had some very nice tests.

889
00:35:13,284 --> 00:35:15,630
I cannot find-- OK, I found it.

890
00:35:15,630 --> 00:35:16,230
400.

891
00:35:16,230 --> 00:35:21,420
So this is creating the
job, mocking the API service

892
00:35:21,420 --> 00:35:26,730
so that if someone tries
to send a post, return 404.

893
00:35:26,730 --> 00:35:29,490
That injects the test
component, runs the job,

894
00:35:29,490 --> 00:35:31,180
checks the appropriate
event to send.

895
00:35:31,180 --> 00:35:38,299
So one of the things is when
some outputs happen as events,

896
00:35:38,300 --> 00:35:40,720
it's not very easy to test them.

897
00:35:40,720 --> 00:35:43,730
In this example I'm using,
in the test application,

898
00:35:43,730 --> 00:35:46,130
I'm using a logging
event bus that basically

899
00:35:46,130 --> 00:35:49,950
logs every single event so that
I can assert on those later on.

900
00:35:49,950 --> 00:35:52,390
Again, there might be different
or better ways to do this.

901
00:35:52,390 --> 00:35:53,765
But this is
something that works.

902
00:35:53,765 --> 00:35:54,650
And we have tests.

903
00:35:54,650 --> 00:36:06,400


904
00:36:06,400 --> 00:36:09,360
AUDIENCE: What's your opinion
on using custom views instead

905
00:36:09,360 --> 00:36:12,530
of fragments so you don't
have to deal with the fragment

906
00:36:12,530 --> 00:36:13,920
quirks, if you will?

907
00:36:13,920 --> 00:36:17,510
So things like child fragment
manager or popping in the back

908
00:36:17,510 --> 00:36:20,092
stack after you
have a saved state.

909
00:36:20,092 --> 00:36:21,800
ADAM POWELL: So again,
I think that those

910
00:36:21,800 --> 00:36:23,540
are kind of unrelated.

911
00:36:23,540 --> 00:36:27,029
Just because a fragment
controls views.

912
00:36:27,030 --> 00:36:28,440
It's not a view itself.

913
00:36:28,440 --> 00:36:29,940
That was kind of
what we were trying

914
00:36:29,940 --> 00:36:32,240
to get at a little bit earlier.

915
00:36:32,240 --> 00:36:34,160
Overall, I think
that a lot of people

916
00:36:34,160 --> 00:36:37,290
write fragments when they really
meant to write a custom view.

917
00:36:37,290 --> 00:36:40,630
So I think that in many
cases, see exactly what it

918
00:36:40,630 --> 00:36:44,530
is that your particular
chunk of encapsulated UI

919
00:36:44,530 --> 00:36:46,747
needs to express and respond to.

920
00:36:46,747 --> 00:36:48,330
If those are events
that can be coming

921
00:36:48,330 --> 00:36:50,240
from some alternate
component that's

922
00:36:50,240 --> 00:36:54,930
kind of composing that piece's
place within the overall UI,

923
00:36:54,930 --> 00:36:57,940
then that speaks to it being
probably a little bit more

924
00:36:57,940 --> 00:36:59,172
like a view group.

925
00:36:59,172 --> 00:37:00,630
If it's something
that really needs

926
00:37:00,630 --> 00:37:04,140
to respond to other
elements of the application

927
00:37:04,140 --> 00:37:06,420
lifecycle and the
activity lifecycle,

928
00:37:06,420 --> 00:37:09,120
if it's doing something
like registering for events,

929
00:37:09,120 --> 00:37:11,299
dealing with things
like that, then it

930
00:37:11,300 --> 00:37:13,500
may be more appropriate for
a fragment in that case.

931
00:37:13,500 --> 00:37:15,240
But overall, I think
that people tend

932
00:37:15,240 --> 00:37:17,859
to lean a little bit
too heavily on fragments

933
00:37:17,860 --> 00:37:19,950
when they think of one
particular subsegment

934
00:37:19,950 --> 00:37:20,529
of their UI.

935
00:37:20,530 --> 00:37:26,485


936
00:37:26,485 --> 00:37:27,730
AUDIENCE: Hi.

937
00:37:27,730 --> 00:37:30,340
One question I had
was, how do you

938
00:37:30,340 --> 00:37:34,020
handle the serialization
of these jobs to disk

939
00:37:34,020 --> 00:37:35,970
and back out when the app dies?

940
00:37:35,970 --> 00:37:39,160
Do you roll your own logic,
or do you use something

941
00:37:39,160 --> 00:37:41,960
like a framework or something?

942
00:37:41,960 --> 00:37:43,710
YIGIT BOYAR: For this
demo application,

943
00:37:43,710 --> 00:37:46,730
I'm using Job Queue, which is
some library I wrote before.

944
00:37:46,730 --> 00:37:48,790
You can simply serialize them.

945
00:37:48,790 --> 00:37:50,360
You can use Tape.

946
00:37:50,360 --> 00:37:52,540
There was recently
another talk to use

947
00:37:52,540 --> 00:37:56,570
Tape to serialize your
stuff, to make it like a job.

948
00:37:56,570 --> 00:37:59,040
There's multiple solutions
for this out there.

949
00:37:59,040 --> 00:38:01,180
It's not that complex either.

950
00:38:01,180 --> 00:38:03,642
You can choose one of them
which fits your needs.

951
00:38:03,642 --> 00:38:04,600
AUDIENCE: Cool, thanks.

952
00:38:04,600 --> 00:38:08,450


953
00:38:08,450 --> 00:38:09,950
ADAM POWELL: We've
got one up front.

954
00:38:09,950 --> 00:38:13,337


955
00:38:13,337 --> 00:38:14,920
AUDIENCE: In this
kind of application,

956
00:38:14,920 --> 00:38:17,620
would you use a sync adapter,
or would you use like async REST

957
00:38:17,620 --> 00:38:20,446
calls to contact the server?

958
00:38:20,446 --> 00:38:21,819
YIGIT BOYAR: So
for the demo-- so

959
00:38:21,820 --> 00:38:24,420
one of the things we gave
in examples in the slides

960
00:38:24,420 --> 00:38:28,950
was to separate your local
tasks from the server tasks.

961
00:38:28,950 --> 00:38:32,410
The way we do it is
for UI-related stuff,

962
00:38:32,410 --> 00:38:34,040
I'm using a sync task.

963
00:38:34,040 --> 00:38:36,500
I never use it for
network, only for UI stuff.

964
00:38:36,500 --> 00:38:39,100
ANd for network, I'm
using the job queue.

965
00:38:39,100 --> 00:38:42,919
So the jobs are the only ones
that are calling the network.

966
00:38:42,919 --> 00:38:45,210
ADAM POWELL: Yeah, the sync
adapter is generally useful

967
00:38:45,210 --> 00:38:48,310
once you have a more
sophisticated account

968
00:38:48,310 --> 00:38:50,790
infrastructure, and you have
some of the other machinery

969
00:38:50,790 --> 00:38:53,279
that that was really
kind of built around.

970
00:38:53,280 --> 00:38:55,730
So if it seems like
you're going through a lot

971
00:38:55,730 --> 00:38:59,255
of additional machinery to
work with a sync adapter,

972
00:38:59,255 --> 00:39:01,380
then maybe start taking a
look at some more things,

973
00:39:01,380 --> 00:39:03,120
just like a job scheduler,
and so on, and so forth,

974
00:39:03,120 --> 00:39:05,000
and see if that's
something that is simpler

975
00:39:05,000 --> 00:39:06,291
that can still meet your needs.

976
00:39:06,291 --> 00:39:10,717


977
00:39:10,717 --> 00:39:13,050
AUDIENCE: When you start
building all these applications

978
00:39:13,050 --> 00:39:15,970
with these different
versions of data models--

979
00:39:15,970 --> 00:39:20,009
so you might have, like, fetch
data off the network, updates

980
00:39:20,010 --> 00:39:23,180
that the user has made to the
data that hasn't been actually

981
00:39:23,180 --> 00:39:26,580
pushed to the database, do
you guys have any classes that

982
00:39:26,580 --> 00:39:29,040
can help us maintain
all this application

983
00:39:29,040 --> 00:39:33,360
logic or any libraries that
you would suggest we use

984
00:39:33,360 --> 00:39:37,710
to maintain all these versions?

985
00:39:37,710 --> 00:39:40,079
ADAM POWELL: Do you
have any suggestions?

986
00:39:40,079 --> 00:39:42,120
YIGIT BOYAR: I'm sorry,
nothing about versioning.

987
00:39:42,120 --> 00:39:45,560
But that actually reminds
me of something I forgot.

988
00:39:45,560 --> 00:39:47,310
One of the important
things in your client

989
00:39:47,310 --> 00:39:50,040
is your client's consistency.

990
00:39:50,040 --> 00:39:51,920
And the server may crash.

991
00:39:51,920 --> 00:39:55,029
But your server may also
start returning bad data.

992
00:39:55,029 --> 00:39:56,570
So one of the things
this client does

993
00:39:56,570 --> 00:39:59,390
is, if I open a user model,
let's say-- everything save.

994
00:39:59,390 --> 00:40:03,779


995
00:40:03,780 --> 00:40:06,660
So before we save
anything, we will date it.

996
00:40:06,660 --> 00:40:09,670
And if it is not valid for this
client, we just throw it out.

997
00:40:09,670 --> 00:40:11,570
Because I don't understand.

998
00:40:11,570 --> 00:40:12,480
The server has a bug.

999
00:40:12,480 --> 00:40:13,896
Maybe the server
is a new version.

1000
00:40:13,896 --> 00:40:15,160
I don't know.

1001
00:40:15,160 --> 00:40:18,020
If I don't understand
object, I throw it out.

1002
00:40:18,020 --> 00:40:20,830
This makes it easier for the
rest of the application to,

1003
00:40:20,830 --> 00:40:24,344
like, OK, if the object is
there, it's properly filled.

1004
00:40:24,344 --> 00:40:26,760
ADAM POWELL: So to the point
of dealing with specific data

1005
00:40:26,760 --> 00:40:28,797
inconsistencies,
especially across upgrades,

1006
00:40:28,797 --> 00:40:30,880
different server versions,
and so on and so forth,

1007
00:40:30,880 --> 00:40:32,838
what we found with working
with a lot of teams,

1008
00:40:32,838 --> 00:40:35,285
both within Google and
external to Google,

1009
00:40:35,285 --> 00:40:39,740
is that many times, the actual
pieces of business logic

1010
00:40:39,740 --> 00:40:41,500
that make an app
interesting tend

1011
00:40:41,500 --> 00:40:44,570
to differ so much between
applications that we've

1012
00:40:44,570 --> 00:40:47,150
had a lot of difficulty finding
a one size fits all solution

1013
00:40:47,150 --> 00:40:50,200
to just offer as a
prescription of, hey everyone,

1014
00:40:50,200 --> 00:40:53,290
go use this for dealing with
this particular problem space.

1015
00:40:53,290 --> 00:40:55,740
It is something that you can
make a lot of assumptions

1016
00:40:55,740 --> 00:40:57,549
based on the shape
of your data and what

1017
00:40:57,550 --> 00:40:59,710
it is that your data is
actually representing.

1018
00:40:59,710 --> 00:41:02,490
So often times, you need
something a lot less complex

1019
00:41:02,490 --> 00:41:05,471
than some general solution that
solves for the entire world.

1020
00:41:05,472 --> 00:41:07,680
But if you've got some ideas,
please track some of us

1021
00:41:07,680 --> 00:41:09,569
down in the halls here.

1022
00:41:09,570 --> 00:41:11,190
And we'd love to
hear about them.

1023
00:41:11,190 --> 00:41:18,400


1024
00:41:18,400 --> 00:41:19,086
Anyone else?

1025
00:41:19,086 --> 00:41:22,350


1026
00:41:22,350 --> 00:41:25,182
All right, well,
thank you very much.

1027
00:41:25,182 --> 00:41:26,140
YIGIT BOYAR: Thank you.

1028
00:41:26,140 --> 00:41:30,140
[APPLAUSE]

1029
00:41:30,140 --> 00:41:41,136


