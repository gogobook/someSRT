1
00:00:00,000 --> 00:00:01,708
YIGIT BOYAR: Oh, good
morning, everybody.

2
00:00:01,708 --> 00:00:03,900
Welcome to the Advanced
Data Binding session.

3
00:00:03,900 --> 00:00:05,600
I'm Yigit Boyar.

4
00:00:05,600 --> 00:00:07,390
GEORGE MOUNT: I'm
George Mount and we're

5
00:00:07,390 --> 00:00:09,980
from the Android UI Toolkit,
part of the Framework team

6
00:00:09,980 --> 00:00:11,780
on Android.

7
00:00:11,780 --> 00:00:14,607
And today let's talk a little
bit about data binding.

8
00:00:14,608 --> 00:00:16,280
[CHEERS AND APPLAUSE]

9
00:00:16,280 --> 00:00:17,660
YIGIT BOYAR: [LAUGHS]

10
00:00:17,660 --> 00:00:19,310
GEORGE MOUNT: All right.

11
00:00:19,310 --> 00:00:22,220
So how many of you have used
data binding in the past?

12
00:00:22,220 --> 00:00:22,990
All right.

13
00:00:22,990 --> 00:00:25,328
How many people think
it's still in beta?

14
00:00:25,329 --> 00:00:25,995
All right, yeah.

15
00:00:25,995 --> 00:00:27,439
Yeah, that's the problem.

16
00:00:27,439 --> 00:00:29,230
We didn't do a great
announcement last fall

17
00:00:29,230 --> 00:00:32,140
when we released it with
Android Studio [? 2.15. ?]

18
00:00:32,140 --> 00:00:34,330
But it is production now.

19
00:00:34,330 --> 00:00:36,031
And you are welcome to use it.

20
00:00:36,031 --> 00:00:37,030
It's production quality.

21
00:00:37,030 --> 00:00:40,200
It's actually doing
very well in the public.

22
00:00:40,200 --> 00:00:42,940
So if you haven't seen it, I
have put a little link here

23
00:00:42,940 --> 00:00:45,260
for our previous
Android data binding

24
00:00:45,260 --> 00:00:48,280
talk at Android Dev Summit.

25
00:00:48,280 --> 00:00:49,664
And you can just click on this.

26
00:00:49,664 --> 00:00:51,080
If you're watching
at home, that's

27
00:00:51,080 --> 00:00:52,699
a great thing to do right now.

28
00:00:52,700 --> 00:00:56,250
Pause it and go see that link.

29
00:00:56,250 --> 00:00:58,385
Because we're going to
show you about four minutes

30
00:00:58,385 --> 00:01:01,961
a quick version of what we did
for about 40 minutes back then.

31
00:01:01,962 --> 00:01:02,920
YIGIT BOYAR: It's good.

32
00:01:02,920 --> 00:01:03,920
GEORGE MOUNT: All right.

33
00:01:03,920 --> 00:01:06,320
So what is data binding?

34
00:01:06,320 --> 00:01:08,970
Well, when we have
a layout like this--

35
00:01:08,970 --> 00:01:10,789
this is my awesome store.

36
00:01:10,790 --> 00:01:13,060
And what I want to
do-- because of course,

37
00:01:13,060 --> 00:01:15,810
I want to get data
into my layout.

38
00:01:15,810 --> 00:01:19,150
And of course, I have
to find the views that

39
00:01:19,150 --> 00:01:20,220
are in my layout.

40
00:01:20,220 --> 00:01:22,980
And then set the
data, all right?

41
00:01:22,980 --> 00:01:25,590
This kind of sucks, right?

42
00:01:25,590 --> 00:01:28,140
I hate doing this.

43
00:01:28,140 --> 00:01:31,965
So we just use
Android data binding.

44
00:01:31,965 --> 00:01:33,740
So let's look at
that layout again.

45
00:01:33,740 --> 00:01:36,809
OK, we want to get rid
of all that setter logic.

46
00:01:36,810 --> 00:01:37,830
That kind of sucks.

47
00:01:37,830 --> 00:01:40,314
FindViewByID really is lousy.

48
00:01:40,314 --> 00:01:42,229
But we have to do something
a little different

49
00:01:42,230 --> 00:01:43,020
in the onCreate.

50
00:01:43,020 --> 00:01:46,259
Instead of calling
setContentView,

51
00:01:46,260 --> 00:01:49,890
we have to have a different
setContentView, which

52
00:01:49,890 --> 00:01:53,050
will create a data binding.

53
00:01:53,050 --> 00:01:57,815
And then we have to set the
data object on that binding.

54
00:01:57,815 --> 00:01:59,065
We can't do only that, though.

55
00:01:59,065 --> 00:02:01,500
We have to modify our
layout just a little bit.

56
00:02:01,500 --> 00:02:04,910
First thing we have to
do is add the layout tag

57
00:02:04,910 --> 00:02:06,009
to the outside of this.

58
00:02:06,010 --> 00:02:07,760
And of course, we move
the namespace stuff

59
00:02:07,760 --> 00:02:10,100
up to the top in the layout tag,
because that's the right thing

60
00:02:10,100 --> 00:02:10,870
to do.

61
00:02:10,870 --> 00:02:12,919
And we have a data tag as well.

62
00:02:12,919 --> 00:02:14,960
It has all the variables
that we're going to use.

63
00:02:14,960 --> 00:02:18,822
In this case, it's
prod for our product.

64
00:02:18,822 --> 00:02:22,920
So that kind of does our
import or sets the variables

65
00:02:22,920 --> 00:02:24,821
that we're going to
use in our layout.

66
00:02:24,822 --> 00:02:26,530
And then we also have
to reference those.

67
00:02:26,530 --> 00:02:31,130
So we assign the values
directly to our source, or text,

68
00:02:31,130 --> 00:02:33,670
or anything else that
we have in our layout.

69
00:02:33,670 --> 00:02:36,579
And here, you can see that we
can use any expression we want.

70
00:02:36,580 --> 00:02:42,489
And we just has the @{ to denote
that it's a data-bound tag.

71
00:02:42,489 --> 00:02:43,447
Let's see how it works.

72
00:02:43,447 --> 00:02:45,610


73
00:02:45,610 --> 00:02:47,735
YIGIT BOYAR: So data binding
looks way too magical.

74
00:02:47,735 --> 00:02:50,655
And you want to briefly
explain that there's actually

75
00:02:50,655 --> 00:02:51,565
more magic.

76
00:02:51,565 --> 00:02:53,220
And like, there's
well-defined steps

77
00:02:53,220 --> 00:02:55,460
how we prepare that is
good for you to know,

78
00:02:55,460 --> 00:02:58,460
because then you have an idea
what's going behind the scenes.

79
00:02:58,460 --> 00:03:00,500
If you get a problem,
you have an idea

80
00:03:00,500 --> 00:03:03,000
where it might be happening.

81
00:03:03,000 --> 00:03:06,667
So while you hit Run
in Android Studio,

82
00:03:06,667 --> 00:03:08,875
the Android Studio starts
compiling your application.

83
00:03:08,875 --> 00:03:10,980
And it merges your resources.

84
00:03:10,980 --> 00:03:14,016
And when the layout
files are merged,

85
00:03:14,016 --> 00:03:17,359
we go pick those
layout files, and then

86
00:03:17,360 --> 00:03:19,432
remove everything
about data binding.

87
00:03:19,432 --> 00:03:22,116
So like everything you put
there about data binding gets

88
00:03:22,116 --> 00:03:22,615
deleted.

89
00:03:22,615 --> 00:03:25,290
So if you put layout with
something data binding,

90
00:03:25,290 --> 00:03:27,980
you lose it.

91
00:03:27,980 --> 00:03:30,299
And then in next step, we
parse these expressions,

92
00:03:30,300 --> 00:03:32,230
so that they are
grammatically correct.

93
00:03:32,230 --> 00:03:34,399
We don't know what you
put makes sense or not,

94
00:03:34,400 --> 00:03:37,130
but they need to be
grammatically correct.

95
00:03:37,130 --> 00:03:39,630
So when we parse, we understand,
OK, there's some, like,

96
00:03:39,630 --> 00:03:41,150
identifiers here.

97
00:03:41,150 --> 00:03:42,730
Accessing your field,
we have no idea

98
00:03:42,730 --> 00:03:44,209
what that is at this stage.

99
00:03:44,209 --> 00:03:45,250
But we know it's correct.

100
00:03:45,250 --> 00:03:49,130
And if it's not, we
will throw an exception.

101
00:03:49,130 --> 00:03:52,570
And next step, your
application code gets compiled.

102
00:03:52,570 --> 00:03:54,519
Like, the Java code you
write gets compiled.

103
00:03:54,520 --> 00:03:56,600
While it's being
compiled, we [? have an ?]

104
00:03:56,600 --> 00:03:59,930
annotation processor that
gets the outputs from what

105
00:03:59,930 --> 00:04:02,820
we parse from the
layout files and tries

106
00:04:02,820 --> 00:04:04,600
to understand what it means.

107
00:04:04,600 --> 00:04:07,320
So let's say you had
something like user.admin.

108
00:04:07,320 --> 00:04:09,066
Now you declare the variable.

109
00:04:09,066 --> 00:04:10,690
We know there was
some user cost there.

110
00:04:10,690 --> 00:04:12,090
We go and find that cost.

111
00:04:12,090 --> 00:04:14,594
Then we try to figure out,
OK, what does isAdmin mean?

112
00:04:14,594 --> 00:04:15,760
Like, is this a method call?

113
00:04:15,760 --> 00:04:17,019
Is this a field?

114
00:04:17,019 --> 00:04:19,006
We figured it out.

115
00:04:19,005 --> 00:04:22,630
We [? will be ?] resulting
like this is admin method,

116
00:04:22,630 --> 00:04:24,650
or you could just
say user.admin.

117
00:04:24,650 --> 00:04:27,440
We will still understand that
this is an is.admin Boolean

118
00:04:27,440 --> 00:04:28,719
method.

119
00:04:28,720 --> 00:04:31,560
And then figure out, OK,
this grammatically correct

120
00:04:31,560 --> 00:04:33,830
expression resolves
into a Boolean value.

121
00:04:33,830 --> 00:04:36,620
Now, when we look
at the attribute,

122
00:04:36,620 --> 00:04:40,050
I will try to find, OK, what
is the setter we need to call?

123
00:04:40,050 --> 00:04:44,770
Is this Visibility integer, or
enabled, whether we resolve it?

124
00:04:44,770 --> 00:04:47,060
And all of this happens
while your application

125
00:04:47,060 --> 00:04:48,520
is being compiled.

126
00:04:48,520 --> 00:04:51,919
Whilst we decide what to
do, we write the binders

127
00:04:51,920 --> 00:04:54,010
to the actual code
that updates the UI.

128
00:04:54,010 --> 00:04:57,090
And you profit.

129
00:04:57,090 --> 00:05:02,599
So really briefly, this
is data-bound layout file.

130
00:05:02,600 --> 00:05:06,020
At the time of compile,
we literally do this.

131
00:05:06,020 --> 00:05:07,150
Like, delete everything.

132
00:05:07,150 --> 00:05:09,659
We try to keep the
files, the lines

133
00:05:09,660 --> 00:05:11,499
match as much as possible.

134
00:05:11,499 --> 00:05:13,040
If you go check your
[? real ?] file,

135
00:05:13,040 --> 00:05:15,520
you will find the
stripped files.

136
00:05:15,520 --> 00:05:17,275
So we get rid of
that layout tag.

137
00:05:17,276 --> 00:05:19,520
Then we get rid of
everything data-binding,

138
00:05:19,520 --> 00:05:21,900
because APT doesn't
know about them.

139
00:05:21,900 --> 00:05:22,929
We clean them.

140
00:05:22,930 --> 00:05:27,690
And then we hit some tags,
so that-- go ahead, OK--

141
00:05:27,690 --> 00:05:31,180
so that when you inflate
layout, we can understand

142
00:05:31,180 --> 00:05:33,860
[? which field is. ?] This is
why even if you don't put IDs

143
00:05:33,860 --> 00:05:37,380
on those [? fields, ?]
we find them.

144
00:05:37,380 --> 00:05:39,307
So George has some
presents for you.

145
00:05:39,307 --> 00:05:40,560
[LAUGHTER]

146
00:05:40,560 --> 00:05:44,080
GEORGE MOUNT: So that's what
we released back in the fall.

147
00:05:44,080 --> 00:05:46,669
Let's see what new
things we have here.

148
00:05:46,670 --> 00:05:47,600
Two-way data binding.

149
00:05:47,600 --> 00:05:50,500
Now, I know I've heard
a lot from you guys out

150
00:05:50,500 --> 00:05:52,840
there that say, you
know, this is great,

151
00:05:52,840 --> 00:05:55,340
but without two-way
data binding,

152
00:05:55,340 --> 00:05:56,962
data binding's useless, right?

153
00:05:56,962 --> 00:05:58,170
I can't believe I heard that.

154
00:05:58,170 --> 00:06:02,520
But I think even one-way data
binding is pretty awesome.

155
00:06:02,520 --> 00:06:04,729
So I saw a few people
trying to do their own thing

156
00:06:04,730 --> 00:06:06,014
for two-way data binding.

157
00:06:06,014 --> 00:06:07,430
And they'd do
something like this,

158
00:06:07,430 --> 00:06:11,460
where they'd do the one-way
data binding with the regular

159
00:06:11,460 --> 00:06:15,880
data-binding field, and then
add another handler for the text

160
00:06:15,880 --> 00:06:17,062
change.

161
00:06:17,062 --> 00:06:18,770
And then they'd have
to check, of course,

162
00:06:18,770 --> 00:06:21,019
whether the change really
happened, or else you end up

163
00:06:21,019 --> 00:06:26,092
with this cycle of loops of
the text changes in the view,

164
00:06:26,092 --> 00:06:27,550
and then it goes
back to the field,

165
00:06:27,550 --> 00:06:30,240
and it sends a text
change message.

166
00:06:30,240 --> 00:06:31,650
So it was kind of a mess.

167
00:06:31,650 --> 00:06:34,710
And also, you end up
having this change handler

168
00:06:34,710 --> 00:06:39,780
for every different bound
view in your layout.

169
00:06:39,780 --> 00:06:41,809
And it really kind of sucked.

170
00:06:41,810 --> 00:06:45,610
So we wanted to do something
a little better than this.

171
00:06:45,610 --> 00:06:47,760
Get rid of all that stuff
that you're used to.

172
00:06:47,760 --> 00:06:51,890
And we can do this all on our
own by just saying @= instead

173
00:06:51,890 --> 00:06:53,300
of just @{, right?

174
00:06:53,300 --> 00:06:57,060
The @= is just kind of a
nice quick and very visible

175
00:06:57,060 --> 00:06:59,700
indicator that this is a
two-way data-bound field.

176
00:06:59,700 --> 00:07:01,849
Now we can bind to
the Android text

177
00:07:01,850 --> 00:07:06,340
field in a very simple way.

178
00:07:06,340 --> 00:07:08,929
Now, you may be wondering, how
does this notification happen?

179
00:07:08,930 --> 00:07:11,329
What's going on
underneath the hood?

180
00:07:11,329 --> 00:07:12,870
This is kind of
important if you were

181
00:07:12,870 --> 00:07:14,729
going to write your
own data-bound fields.

182
00:07:14,729 --> 00:07:17,020
So first thing we have to
know is what kind of listener

183
00:07:17,020 --> 00:07:17,945
should we add?

184
00:07:17,945 --> 00:07:19,980
We don't want to
use TextWatcher,

185
00:07:19,980 --> 00:07:23,860
because that's only useful
for text views or edit text.

186
00:07:23,860 --> 00:07:27,469
We don't want to use--
I don't know, what?

187
00:07:27,469 --> 00:07:28,510
YIGIT BOYAR: Time change.

188
00:07:28,510 --> 00:07:29,060
GEORGE MOUNT: Time change.

189
00:07:29,060 --> 00:07:30,800
Yeah, date change or
something like that.

190
00:07:30,800 --> 00:07:31,480
That wouldn't be good.

191
00:07:31,480 --> 00:07:32,730
So we have some
kind of generic one.

192
00:07:32,730 --> 00:07:34,438
It's called the inverse
binding listener.

193
00:07:34,438 --> 00:07:36,340
And this is basically
telling us that there's

194
00:07:36,340 --> 00:07:39,510
been a change on your view.

195
00:07:39,510 --> 00:07:42,490
And what happens is
your binding implements

196
00:07:42,490 --> 00:07:44,550
this listener for you.

197
00:07:44,550 --> 00:07:48,500
And this is code almost straight
out of the generated code.

198
00:07:48,500 --> 00:07:50,560
So you can see here
that what's going on

199
00:07:50,560 --> 00:07:53,719
is it's getting the
text from the view.

200
00:07:53,719 --> 00:07:55,510
And then it does, of
course, null checking.

201
00:07:55,510 --> 00:07:57,690
You guys have to make sure
to do all null checking.

202
00:07:57,690 --> 00:07:59,660
Everyone here always
double-checks their variables,

203
00:07:59,660 --> 00:07:59,925
right?

204
00:07:59,925 --> 00:08:00,510
OK?

205
00:08:00,510 --> 00:08:00,840
Everyone?

206
00:08:00,840 --> 00:08:01,270
Yeah.

207
00:08:01,270 --> 00:08:01,580
I see.

208
00:08:01,580 --> 00:08:02,909
YIGIT BOYAR: You're not
using data-binding, though.

209
00:08:02,910 --> 00:08:03,596
[LAUGHTER]

210
00:08:03,596 --> 00:08:04,721
You don't need null checks.

211
00:08:04,721 --> 00:08:05,827
GEORGE MOUNT: Yeah.

212
00:08:05,827 --> 00:08:06,785
YIGIT BOYAR: It's 2016.

213
00:08:06,785 --> 00:08:08,830
GEORGE MOUNT:
Yeah, that's right.

214
00:08:08,830 --> 00:08:10,080
Who has no pointer exceptions?

215
00:08:10,080 --> 00:08:10,490
I don't know.

216
00:08:10,490 --> 00:08:10,870
Nobody.

217
00:08:10,870 --> 00:08:12,110
YIGIT BOYAR: Which language?

218
00:08:12,110 --> 00:08:13,410
GEORGE MOUNT: And then it
finally sets the field.

219
00:08:13,410 --> 00:08:15,660
You can see here that it's
actually setting this field

220
00:08:15,660 --> 00:08:17,897
as an observable field.

221
00:08:17,897 --> 00:08:19,730
And actually, you might
be interested to see

222
00:08:19,730 --> 00:08:25,265
that this comment here is
actually in the generated code.

223
00:08:25,265 --> 00:08:27,390
So if you wanted to go look
at that generated code,

224
00:08:27,390 --> 00:08:28,889
you'll see this
comment and see what

225
00:08:28,889 --> 00:08:30,669
the inverse of
this expression is

226
00:08:30,669 --> 00:08:32,960
to help you try to debug if
you have a problem with it.

227
00:08:32,960 --> 00:08:36,039


228
00:08:36,039 --> 00:08:39,130
So let's look at how you
get that field's value.

229
00:08:39,130 --> 00:08:41,080
We just saw that--
getting the field's value.

230
00:08:41,080 --> 00:08:43,960
And one thing to do is to
try to annotate the quickest

231
00:08:43,960 --> 00:08:52,040
annotation, which will give
you a getter for your view.

232
00:08:52,040 --> 00:08:54,000
So here we have
a text view type.

233
00:08:54,000 --> 00:08:59,130
And we want to know what is
the getter for android:text.

234
00:08:59,130 --> 00:09:00,420
Now, we have this method.

235
00:09:00,420 --> 00:09:01,425
We can just declare it.

236
00:09:01,425 --> 00:09:02,560
It's a getText.

237
00:09:02,560 --> 00:09:06,979
But if you don't supply
it, there's a default.

238
00:09:06,980 --> 00:09:08,790
And it just uses
the attribute name.

239
00:09:08,790 --> 00:09:11,349
So even if we didn't supply
anything, it would use getTest,

240
00:09:11,350 --> 00:09:15,210
because the attribute
is android:text.

241
00:09:15,210 --> 00:09:17,760
So it's kind of smart that way.

242
00:09:17,760 --> 00:09:20,770
And we have this
synthetic attribute.

243
00:09:20,770 --> 00:09:22,730
This is for the event.

244
00:09:22,730 --> 00:09:24,760
This is the event that
notifies that there's

245
00:09:24,760 --> 00:09:27,600
been a change in that view.

246
00:09:27,600 --> 00:09:29,832
And again, there's
a default here.

247
00:09:29,832 --> 00:09:31,540
If we didn't supply
anything, it would be

248
00:09:31,540 --> 00:09:34,469
android:textAttrChanged.

249
00:09:34,470 --> 00:09:36,740
So most of the time, you
wouldn't supply anything here

250
00:09:36,740 --> 00:09:38,190
at all.

251
00:09:38,190 --> 00:09:41,260
Now I want to talk a
little bit more about this.

252
00:09:41,260 --> 00:09:44,380
So we, of course, have
to get notifications

253
00:09:44,380 --> 00:09:46,490
from the text view.

254
00:09:46,490 --> 00:09:48,900
And so this is what you'd
normally do for a text view.

255
00:09:48,900 --> 00:09:50,480
You have to set a TextWatcher.

256
00:09:50,480 --> 00:09:53,330
And so we have these
event attributes

257
00:09:53,330 --> 00:09:55,790
in the binding adapter.

258
00:09:55,790 --> 00:09:59,569
And so we just add
this other attribute,

259
00:09:59,570 --> 00:10:00,600
the synthetic attribute.

260
00:10:00,600 --> 00:10:02,060
Now, the synthetic
attribute-- you

261
00:10:02,060 --> 00:10:03,739
can't use this in your layout.

262
00:10:03,740 --> 00:10:05,050
We check against it.

263
00:10:05,050 --> 00:10:07,750
So if you try to
do that, it's going

264
00:10:07,750 --> 00:10:12,720
to throw up a nice exception for
you or error message for you.

265
00:10:12,720 --> 00:10:16,054
But anyway, so you can now set
this in your binding adapter.

266
00:10:16,054 --> 00:10:17,720
And this is, of course,
all done for you

267
00:10:17,720 --> 00:10:19,727
for all the fields that work.

268
00:10:19,727 --> 00:10:21,310
And of course, what
do you have to do?

269
00:10:21,310 --> 00:10:22,969
You have to remove
the previous one,

270
00:10:22,970 --> 00:10:25,200
and then you have
to add a new one.

271
00:10:25,200 --> 00:10:28,140
And you have to notify them
only if they're not null, right?

272
00:10:28,140 --> 00:10:29,640
We don't want to
notify null things,

273
00:10:29,640 --> 00:10:33,232
because we, of course,
want to do null checking.

274
00:10:33,232 --> 00:10:35,439
And we also have to notify
our onChange [? Lister ?].

275
00:10:35,440 --> 00:10:38,490
So now we know that when
that text views changes,

276
00:10:38,490 --> 00:10:42,060
it's going to call our
generated onChange.

277
00:10:42,060 --> 00:10:44,920
Now, if you have a more
complex getter-- well,

278
00:10:44,920 --> 00:10:47,810
this is not very complex, but
this is a little more complex.

279
00:10:47,810 --> 00:10:52,180
The text view doesn't return
a string, it returns what?

280
00:10:52,180 --> 00:10:53,013
[INTERPOSING VOICES]

281
00:10:53,014 --> 00:10:53,804
GEORGE MOUNT: Yeah.

282
00:10:53,804 --> 00:10:54,990
Char sequence, right?

283
00:10:54,990 --> 00:10:57,135
And who here uses
char sequences?

284
00:10:57,135 --> 00:10:58,390
Ah, nobody uses char sequence.

285
00:10:58,390 --> 00:11:00,485
If you try to assign char
sequence to a string?

286
00:11:00,485 --> 00:11:01,620
Typecast error.

287
00:11:01,620 --> 00:11:03,550
So this is a little
more convenient.

288
00:11:03,550 --> 00:11:06,130
So you have a
getTextString, which

289
00:11:06,130 --> 00:11:10,937
will automatically convert your
char sequence into a string.

290
00:11:10,937 --> 00:11:13,020
And so this kind of thing
will help you with that.

291
00:11:13,020 --> 00:11:14,860
And again, we have
this attribute.

292
00:11:14,860 --> 00:11:17,750
And the other field is
also there-- the event.

293
00:11:17,750 --> 00:11:19,462
And it's automatically
defaulted.

294
00:11:19,462 --> 00:11:21,170
And we talked a little
about these cycles

295
00:11:21,170 --> 00:11:25,664
before, where if you have a
text view or an edit text,

296
00:11:25,664 --> 00:11:27,080
and it makes a
change, of course--

297
00:11:27,080 --> 00:11:29,320
it's going to change
your data field.

298
00:11:29,320 --> 00:11:31,300
And if you have a change
in the data field,

299
00:11:31,300 --> 00:11:33,264
it's going to change
your [? header ?] text.

300
00:11:33,264 --> 00:11:35,180
Now, that really sucks,
because what happened?

301
00:11:35,180 --> 00:11:38,969
User typed A, and now it just
set the text on that again,

302
00:11:38,970 --> 00:11:40,347
and you lost your cursor.

303
00:11:40,347 --> 00:11:41,316
YIGIT BOYAR: Oh!

304
00:11:41,316 --> 00:11:42,690
Yeah, something
you will realize.

305
00:11:42,690 --> 00:11:46,020
If you set the text on a text
view, it went to the same text.

306
00:11:46,020 --> 00:11:47,910
It'll still call
the change watchers,

307
00:11:47,910 --> 00:11:50,430
it'll still
[? have ?] the layout,

308
00:11:50,430 --> 00:11:53,031
because inside [INAUDIBLE]
actually a different

309
00:11:53,032 --> 00:11:53,990
[? spendable ?] string.

310
00:11:53,990 --> 00:11:56,650
It has some other format,
so we have to do that.

311
00:11:56,650 --> 00:11:57,600
GEORGE MOUNT: Yeah.

312
00:11:57,600 --> 00:11:59,350
YIGIT BOYAR: So
data-binding gets covered.

313
00:11:59,350 --> 00:12:00,140
How is that?

314
00:12:00,140 --> 00:12:01,556
GEORGE MOUNT: Well,
actually, it's

315
00:12:01,556 --> 00:12:04,414
going to do it more now,
because it just recognized

316
00:12:04,414 --> 00:12:05,580
that there's another change.

317
00:12:05,580 --> 00:12:07,530
And of course, it's going
to send another text change.

318
00:12:07,530 --> 00:12:09,290
And it's going to keep on
going on and on and on.

319
00:12:09,290 --> 00:12:10,360
And that kind of sucks.

320
00:12:10,360 --> 00:12:13,750
Nobody wants to see infinite
cycles in data binding.

321
00:12:13,750 --> 00:12:14,910
So let's solve it!

322
00:12:14,910 --> 00:12:17,930
We're gonna solve it
once and for all, right?

323
00:12:17,930 --> 00:12:19,901
Well, unfortunately, no.

324
00:12:19,902 --> 00:12:21,180
[LAUGHTER]

325
00:12:21,180 --> 00:12:23,260
But you can solve it.

326
00:12:23,260 --> 00:12:26,230
And we solve it for all
the ones we've implemented.

327
00:12:26,230 --> 00:12:28,704
You just have the check in
the binding adapter that says,

328
00:12:28,704 --> 00:12:31,245
when you've set the text field,
we checked the previous value

329
00:12:31,245 --> 00:12:33,480
and made sure that
it hasn't changed.

330
00:12:33,480 --> 00:12:35,490
If it has changed,
then we'll just set it.

331
00:12:35,490 --> 00:12:37,490
If it hasn't changed,
then we don't set it.

332
00:12:37,490 --> 00:12:39,669
And that breaks the
cycle before we can

333
00:12:39,669 --> 00:12:40,960
get this kind of infinite loop.

334
00:12:40,960 --> 00:12:43,417


335
00:12:43,417 --> 00:12:45,000
YIGIT BOYAR: So this
kind of solutions

336
00:12:45,000 --> 00:12:46,280
we do in data binding.

337
00:12:46,280 --> 00:12:48,920
So changing the framework,
that's an option for us.

338
00:12:48,920 --> 00:12:50,949
But it'll only work
in the new devices.

339
00:12:50,950 --> 00:12:55,300
By doing these work-arounds, we
can support data binding API 7?

340
00:12:55,300 --> 00:12:57,620
GEORGE MOUNT: API
7, that's right.

341
00:12:57,620 --> 00:12:59,830
So does this work
on all attributes?

342
00:12:59,830 --> 00:13:00,530
Well, no.

343
00:13:00,530 --> 00:13:01,370
Clearly not.

344
00:13:01,370 --> 00:13:02,772
Because we need events.

345
00:13:02,772 --> 00:13:04,980
We need events to know
whether the field has changed,

346
00:13:04,980 --> 00:13:06,460
whether the attribute
has changed.

347
00:13:06,460 --> 00:13:07,834
And so we only
work with the ones

348
00:13:07,834 --> 00:13:11,609
that have change events,
so like TextWatcher,

349
00:13:11,610 --> 00:13:13,802
like CheckedChanged.

350
00:13:13,802 --> 00:13:15,010
So these are external events.

351
00:13:15,010 --> 00:13:18,030
These are not on
whatever changed events.

352
00:13:18,030 --> 00:13:21,089
So the good thing is
that almost everything

353
00:13:21,090 --> 00:13:24,635
you care about already has
a change notification on it.

354
00:13:24,635 --> 00:13:26,760
These are the things the
user's clicking on, right?

355
00:13:26,760 --> 00:13:29,000
They're typing in
the Edit field.

356
00:13:29,000 --> 00:13:29,770
So this is great.

357
00:13:29,770 --> 00:13:31,561
So we already have
notifications for these.

358
00:13:31,561 --> 00:13:33,750
So that will work for
almost all the attributes

359
00:13:33,750 --> 00:13:35,580
that you really care about.

360
00:13:35,580 --> 00:13:37,890
But if you have
your own fuse, you

361
00:13:37,890 --> 00:13:40,230
need to do this, have
an external event

362
00:13:40,230 --> 00:13:44,030
that you can set a listener on.

363
00:13:44,030 --> 00:13:44,819
All right.

364
00:13:44,820 --> 00:13:47,620
Let's talk a little bit
about expression chaining.

365
00:13:47,620 --> 00:13:51,920
Now, here I have a
layout with three views.

366
00:13:51,920 --> 00:13:55,434
And they all have the
same expression in it.

367
00:13:55,434 --> 00:13:57,922
It's kind of ugly code.

368
00:13:57,922 --> 00:14:01,340
Like, it's all UI code,
but it's a little ugly.

369
00:14:01,340 --> 00:14:03,630
And I really don't
want to do that.

370
00:14:03,630 --> 00:14:06,290
I'd like to have it once and
then re-use it elsewhere.

371
00:14:06,290 --> 00:14:11,599
So what I can do is create
an ID that I can later

372
00:14:11,600 --> 00:14:15,060
use in my other expressions.

373
00:14:15,060 --> 00:14:17,969
So now we could just
bind to another field.

374
00:14:17,970 --> 00:14:18,679
It's pretty nice.

375
00:14:18,679 --> 00:14:21,093
What it's doing under the hood,
of course, is just saying,

376
00:14:21,094 --> 00:14:22,716
oh, I recognize
that one, we already

377
00:14:22,716 --> 00:14:24,090
had a bound
expression there, I'm

378
00:14:24,090 --> 00:14:25,340
just going to substitute that.

379
00:14:25,340 --> 00:14:28,872


380
00:14:28,872 --> 00:14:30,329
We also have implied
event updates.

381
00:14:30,330 --> 00:14:33,290
So you combined, for
example, to a checked field

382
00:14:33,290 --> 00:14:36,689
in another view, because checked
is a two-way data bind field.

383
00:14:36,690 --> 00:14:39,570
So we can just say, oh,
look, that field over there

384
00:14:39,570 --> 00:14:42,220
was-- the user
clicked on it, and we

385
00:14:42,220 --> 00:14:43,840
get an update right away.

386
00:14:43,840 --> 00:14:45,270
We know what happened.

387
00:14:45,270 --> 00:14:48,182
Let's talk a little bit
about lambda expressions.

388
00:14:48,182 --> 00:14:49,700
YIGIT BOYAR: So
two-way data binding

389
00:14:49,700 --> 00:14:53,200
is one way of grabbing
the data from the layout

390
00:14:53,200 --> 00:14:54,860
back to your data model.

391
00:14:54,860 --> 00:14:56,400
Another way is
the callback side.

392
00:14:56,400 --> 00:14:58,699
[INAUDIBLE] is you
get a view, you

393
00:14:58,700 --> 00:15:00,630
set a click list around that.

394
00:15:00,630 --> 00:15:02,780
So we wanted to make
it a little bit better.

395
00:15:02,780 --> 00:15:06,180
So in two days [? data, ?]
before we introduced this

396
00:15:06,180 --> 00:15:09,390
feature, what you will do with
data binding is that you would

397
00:15:09,390 --> 00:15:11,460
give the [? event ?] an ID.

398
00:15:11,460 --> 00:15:14,640
And then in your Java
code, you will get an ID

399
00:15:14,640 --> 00:15:15,689
from the binding.

400
00:15:15,690 --> 00:15:17,840
We already create
the view for you.

401
00:15:17,840 --> 00:15:20,280
And then you will set a
ClickListener on that.

402
00:15:20,280 --> 00:15:22,030
So we want to make it intuitive.

403
00:15:22,030 --> 00:15:24,589


404
00:15:24,590 --> 00:15:25,860
We got rid of that.

405
00:15:25,860 --> 00:15:29,840
We introduced method references,
so that you could say,

406
00:15:29,840 --> 00:15:34,060
hey, we know
OnClick is an event.

407
00:15:34,060 --> 00:15:35,760
So where does this
presenter come from?

408
00:15:35,760 --> 00:15:37,718
The [INAUDIBLE] and other
variable you declare.

409
00:15:37,718 --> 00:15:39,050
So there's still no magic.

410
00:15:39,050 --> 00:15:41,579
It's not like the
OnClick event you

411
00:15:41,580 --> 00:15:45,140
have in the activity
in the framework.

412
00:15:45,140 --> 00:15:46,780
So in the Presenter,
what you would do

413
00:15:46,780 --> 00:15:49,289
is-- so we will [? tightly ?]
call this method.

414
00:15:49,289 --> 00:15:51,080
You will receive the
view, because onClick,

415
00:15:51,080 --> 00:15:53,890
as soon as it receives the
view, you will get the binding.

416
00:15:53,890 --> 00:15:55,560
So this is a cool method.

417
00:15:55,560 --> 00:15:58,579
Like data binding, it
has a findBinding method

418
00:15:58,580 --> 00:16:00,040
from any view.

419
00:16:00,040 --> 00:16:01,933
And you will get
the item from there

420
00:16:01,933 --> 00:16:04,700
and then do whatever you
want to do with that.

421
00:16:04,700 --> 00:16:07,230
But this is still a lot
of unnecessary code.

422
00:16:07,230 --> 00:16:09,840
So we wanted to make
this a little bit easier.

423
00:16:09,840 --> 00:16:13,520
We introduced
lambda expressions.

424
00:16:13,520 --> 00:16:15,050
So you get rid of that.

425
00:16:15,050 --> 00:16:18,870
You could instead just
say, when onClick happens,

426
00:16:18,870 --> 00:16:21,390
just call presenter.save
with the item.

427
00:16:21,390 --> 00:16:23,240
Where does the item come from?

428
00:16:23,240 --> 00:16:25,650
It's the item that
you declared there.

429
00:16:25,650 --> 00:16:28,030
So in your same method
in the presenter,

430
00:16:28,030 --> 00:16:31,120
like, you can do whatever you
want now you have the item.

431
00:16:31,120 --> 00:16:32,600
What is very cool--
actually, the

432
00:16:32,600 --> 00:16:36,160
reason why we pushed-- so
we had this in the timeline.

433
00:16:36,160 --> 00:16:37,959
But we pushed this
feature a little bit

434
00:16:37,960 --> 00:16:39,770
earlier, because
the testing team

435
00:16:39,770 --> 00:16:42,460
was releasing these
architectural demos

436
00:16:42,460 --> 00:16:43,453
from Google.

437
00:16:43,453 --> 00:16:46,790
And for the [? MDVM, ?] they
wanted something like this.

438
00:16:46,790 --> 00:16:51,099
When you do this, the presenter
has zero Android code.

439
00:16:51,100 --> 00:16:54,030
So your layout file handles
everything specific to Android.

440
00:16:54,030 --> 00:16:56,485
You can just test your
presenter the way you want this.

441
00:16:56,485 --> 00:16:58,410
It's so beautiful separation.

442
00:16:58,410 --> 00:17:00,730
It works very well and
makes it very clean.

443
00:17:00,730 --> 00:17:04,368
Another very cool thing here is
that in Android Studio today,

444
00:17:04,368 --> 00:17:09,919
you can go, roll over the same
function there, click on it,

445
00:17:09,920 --> 00:17:11,770
and go to the Presenter.

446
00:17:11,770 --> 00:17:15,618
So much easier to navigate the
code while we are developing.

447
00:17:15,618 --> 00:17:18,300
So I see [? lists ?] get
a little bit more details.

448
00:17:18,300 --> 00:17:20,569
So it's a lambda expression.

449
00:17:20,569 --> 00:17:21,980
You can also write this.

450
00:17:21,980 --> 00:17:24,180
The onClick receives a view.

451
00:17:24,180 --> 00:17:26,355
So if you look at the
description of the onClick

452
00:17:26,355 --> 00:17:29,216
callback class, this
is how it looks like.

453
00:17:29,216 --> 00:17:30,840
So you can actually
reference that view

454
00:17:30,840 --> 00:17:33,439
in the lambda expression
if you want to use it.

455
00:17:33,440 --> 00:17:36,030


456
00:17:36,030 --> 00:17:38,790
And then the view inside the
expression refers to the one

457
00:17:38,790 --> 00:17:41,004
that you declared in
the Parameter section.

458
00:17:41,005 --> 00:17:45,630
So just like the Java,
eight lambda functions.

459
00:17:45,630 --> 00:17:47,470
And at least you
have-- you can actually

460
00:17:47,470 --> 00:17:48,760
name it whatever you want.

461
00:17:48,760 --> 00:17:53,210
So I named it v. The name
doesn't need to match anything.

462
00:17:53,210 --> 00:17:56,217
So let's look at the other
example, the FocusChange.

463
00:17:56,217 --> 00:17:58,050
So you want to know
when the FocusChange is.

464
00:17:58,050 --> 00:18:03,560
You want to call your presenter
with whatever the new focus is.

465
00:18:03,560 --> 00:18:05,030
Unfortunately, you
cannot do this,

466
00:18:05,030 --> 00:18:07,290
because if you look at
[? all ?] FocusChange methods

467
00:18:07,290 --> 00:18:10,540
or FocusChange clause, the
method receives the view

468
00:18:10,540 --> 00:18:12,240
and the focus state.

469
00:18:12,240 --> 00:18:16,200
So even if you don't want to
use the view clause, the v

470
00:18:16,200 --> 00:18:18,020
parameter, you
have to declare it.

471
00:18:18,020 --> 00:18:22,180
So the rule here is you either
declare all of the arguments

472
00:18:22,180 --> 00:18:26,030
that the method receives,
or you declare none.

473
00:18:26,030 --> 00:18:28,510
We figured out not
declaring [INAUDIBLE]

474
00:18:28,510 --> 00:18:29,520
very common use case.

475
00:18:29,520 --> 00:18:32,400
Like, in the ClickListener, you
almost never want to [? be ?]

476
00:18:32,400 --> 00:18:33,520
[? there ?] anyways.

477
00:18:33,520 --> 00:18:38,320
So we want to provide
that no-argument shortcut.

478
00:18:38,320 --> 00:18:40,379
Another example is onLongClick.

479
00:18:40,380 --> 00:18:42,140
Now, the difference
about onLongClick

480
00:18:42,140 --> 00:18:46,050
is it actually expects a
Boolean value as a result,

481
00:18:46,050 --> 00:18:49,030
so that we know we want
to populate it or not.

482
00:18:49,030 --> 00:18:52,639
So for this to
work, the presenter

483
00:18:52,640 --> 00:18:56,030
show many method-- also needs
to return a Boolean value.

484
00:18:56,030 --> 00:18:59,720
So we are not going to-- if
you put some lambda expression

485
00:18:59,720 --> 00:19:03,050
there that doesn't return the
value expected by the callback,

486
00:19:03,050 --> 00:19:04,360
it's not going to compile.

487
00:19:04,360 --> 00:19:07,580
We don't want to, you know, oh,
this, by default, return false.

488
00:19:07,580 --> 00:19:09,060
And something breaks
in the future.

489
00:19:09,060 --> 00:19:09,768
You have no idea.

490
00:19:09,768 --> 00:19:12,860
So if things don't match,
we don't try to do magic.

491
00:19:12,860 --> 00:19:14,770
We fail.

492
00:19:14,770 --> 00:19:17,070
So there is two ways
to do the same thing.

493
00:19:17,070 --> 00:19:19,919
There is the lambda expressions
and the method references.

494
00:19:19,920 --> 00:19:21,430
They are both useful.

495
00:19:21,430 --> 00:19:24,790
I want to go over what the
difference is, because they

496
00:19:24,790 --> 00:19:27,100
actually behave differently.

497
00:19:27,100 --> 00:19:29,919
So the major difference
between the two

498
00:19:29,920 --> 00:19:32,450
is lambda expressions
are evaluated

499
00:19:32,450 --> 00:19:33,490
when the event happens.

500
00:19:33,490 --> 00:19:36,540
So whatever expression
you put there,

501
00:19:36,540 --> 00:19:39,080
we evaluate it when user
clicks on a button, or the text

502
00:19:39,080 --> 00:19:40,970
changes, or whatever.

503
00:19:40,970 --> 00:19:42,770
The method references,
on the other hand,

504
00:19:42,770 --> 00:19:44,790
is evaluated by
me refresh the UI.

505
00:19:44,790 --> 00:19:47,605
When something is evaluated,
when we refresh the UI,

506
00:19:47,605 --> 00:19:49,710
we evaluate the
expression, we figure out

507
00:19:49,710 --> 00:19:52,750
which method wants to be
called, and set a ClickListener

508
00:19:52,750 --> 00:19:54,760
that directly references
that [? one. ?]

509
00:19:54,760 --> 00:19:56,415
So let's look at the example.

510
00:19:56,415 --> 00:19:58,010
It will be more clear.

511
00:19:58,010 --> 00:20:00,690
So the previous one
where we had a presenter,

512
00:20:00,690 --> 00:20:03,700
let's say I set it to null.

513
00:20:03,700 --> 00:20:05,560
And the presenters--
that same method

514
00:20:05,560 --> 00:20:08,750
was linked into the same button.

515
00:20:08,750 --> 00:20:11,350
So if we look at
saveButton.getClickListener,

516
00:20:11,350 --> 00:20:13,939
so in this case, when
the presenter is null,

517
00:20:13,940 --> 00:20:16,640
does the same button
have a ClickListener?

518
00:20:16,640 --> 00:20:19,990
If you are using
lambda expressions, no.

519
00:20:19,990 --> 00:20:22,100
It actually still
has a same button.

520
00:20:22,100 --> 00:20:23,679
Like, this not null.

521
00:20:23,680 --> 00:20:25,150
Even if you don't
have a presenter,

522
00:20:25,150 --> 00:20:27,960
there's a callback in that view.

523
00:20:27,960 --> 00:20:30,460
But if you are using method
references, yes, it's null.

524
00:20:30,460 --> 00:20:32,070
Like, we don't set it.

525
00:20:32,070 --> 00:20:34,580
So sometimes setting a view
clickable has side effects

526
00:20:34,580 --> 00:20:35,840
and is important for you.

527
00:20:35,840 --> 00:20:37,630
You will need to use
the method references.

528
00:20:37,631 --> 00:20:40,000


529
00:20:40,000 --> 00:20:41,690
But we will take
care of [INAUDIBLE].

530
00:20:41,690 --> 00:20:44,180
So you are not going to crash
even if there's a callback.

531
00:20:44,180 --> 00:20:45,400
When the callback
[? grounds, ?] we

532
00:20:45,400 --> 00:20:46,983
will figure out there
is no presenter,

533
00:20:46,983 --> 00:20:49,604
and it will just drop it.

534
00:20:49,604 --> 00:20:52,970
So the way it works is when you
inflate the layout-- if you're

535
00:20:52,970 --> 00:20:55,640
using lambda expression,
we inflate the layout,

536
00:20:55,640 --> 00:20:56,970
we set the ClickListener.

537
00:20:56,970 --> 00:20:58,822
It belongs to us.

538
00:20:58,822 --> 00:21:01,280
And then when the click happens,
we evaluate the presenter,

539
00:21:01,280 --> 00:21:05,510
we evaluate the parameters,
and then run it.

540
00:21:05,510 --> 00:21:07,860
If you are using a
method reference, when

541
00:21:07,860 --> 00:21:10,010
we execute bindings,
this is the method

542
00:21:10,010 --> 00:21:11,935
that we generate
that updates the UI.

543
00:21:11,935 --> 00:21:15,320
When we run that method, we
will figure out the presenter.

544
00:21:15,320 --> 00:21:18,230
And if there is a
presenter, we will wrap it

545
00:21:18,230 --> 00:21:21,840
in a listener class, which
calls the related method.

546
00:21:21,840 --> 00:21:25,472
And if there is not, we
set the callback to null.

547
00:21:25,472 --> 00:21:26,930
And the listener
clause we generate

548
00:21:26,930 --> 00:21:28,960
looks like just something
simple like this.

549
00:21:28,960 --> 00:21:30,550
It receives the presenter.

550
00:21:30,550 --> 00:21:32,360
So we compare our
reference to that one.

551
00:21:32,360 --> 00:21:33,641
And then we can call it back.

552
00:21:33,642 --> 00:21:35,850
That presenter comes from
the presenter we evaluated.

553
00:21:35,850 --> 00:21:38,570


554
00:21:38,570 --> 00:21:40,595
Another difference is
you can use expressions.

555
00:21:40,595 --> 00:21:43,000
This is the one we get
[? advantage ?] for lambda

556
00:21:43,000 --> 00:21:45,730
expressions-- that you can
use any expression inside

557
00:21:45,730 --> 00:21:48,680
the lambda versus you cannot
do that in method expressions.

558
00:21:48,680 --> 00:21:52,030
So you could say, like,
presenter.save(user.friend).

559
00:21:52,030 --> 00:21:54,270
And we will evaluate it.

560
00:21:54,270 --> 00:21:56,470
Or you could say,
like, data.presenter.

561
00:21:56,470 --> 00:21:59,190
Anything that's valid in data
binding, you can use it there,

562
00:21:59,190 --> 00:22:01,700
and we will evaluate it.

563
00:22:01,700 --> 00:22:05,440
Versus in method expressions,
you cannot do that.

564
00:22:05,440 --> 00:22:08,820
And the method has
to match the event.

565
00:22:08,820 --> 00:22:12,500
But you could still say, like,
data.presenter, same method.

566
00:22:12,500 --> 00:22:14,940
So you can have an expression
to the beginning of it,

567
00:22:14,940 --> 00:22:16,690
but you cannot change
the call parameters.

568
00:22:16,690 --> 00:22:20,270


569
00:22:20,270 --> 00:22:22,310
The callback parameters--
in both of them,

570
00:22:22,310 --> 00:22:23,580
you can access it.

571
00:22:23,580 --> 00:22:25,080
So if you are using
a presenter, you

572
00:22:25,080 --> 00:22:26,620
have to declare it
yourself-- like, I

573
00:22:26,621 --> 00:22:28,060
want to access the view.

574
00:22:28,060 --> 00:22:30,500
So you declare the parameter.

575
00:22:30,500 --> 00:22:31,350
I'm sorry.

576
00:22:31,350 --> 00:22:32,780
Wrong button.

577
00:22:32,780 --> 00:22:35,680
And if you are using the method
references, it already works.

578
00:22:35,680 --> 00:22:38,224
It has to match.

579
00:22:38,224 --> 00:22:40,389
GEORGE MOUNT: Now, you can
use a few extra variables

580
00:22:40,390 --> 00:22:43,890
now in your lambda expressions
that you couldn't use before.

581
00:22:43,890 --> 00:22:46,170
One of them is view IDs.

582
00:22:46,170 --> 00:22:46,720
OK?

583
00:22:46,720 --> 00:22:49,680
You can reference your views
right in the expression.

584
00:22:49,680 --> 00:22:52,210
And it's your view ID,
and it's referenced

585
00:22:52,210 --> 00:22:54,380
as the camel-casified version.

586
00:22:54,380 --> 00:22:59,680
And this is the same field
that you use in your binding.

587
00:22:59,680 --> 00:23:03,736
So we camel-casify it just
the way we did before.

588
00:23:03,736 --> 00:23:05,110
And you can also
use the context.

589
00:23:05,110 --> 00:23:07,669
We found that many of
you wanted to access

590
00:23:07,670 --> 00:23:11,270
the context without
accessing a specific view.

591
00:23:11,270 --> 00:23:13,340
So we just give you the
context of the root.

592
00:23:13,340 --> 00:23:16,580
And you can use this as kind of
a generated, synthetic variable

593
00:23:16,580 --> 00:23:19,292
that you can use right
there in your layout.

594
00:23:19,292 --> 00:23:21,290
YIGIT BOYAR: But if
you create something

595
00:23:21,290 --> 00:23:23,534
that's called context,
then we won't do that.

596
00:23:23,535 --> 00:23:24,977
GEORGE MOUNT: Yeah,
don't do that.

597
00:23:24,977 --> 00:23:26,560
YIGIT BOYAR: But
please don't do that.

598
00:23:26,560 --> 00:23:27,780
[LAUGHTER]

599
00:23:27,780 --> 00:23:29,779
GEORGE MOUNT: Yeah, it
will override our context

600
00:23:29,779 --> 00:23:32,120
if you do that.

601
00:23:32,120 --> 00:23:33,939
All right, let's talk
about animations.

602
00:23:33,940 --> 00:23:35,018
Animations.

603
00:23:35,018 --> 00:23:37,226
Everyone wants to use
animations in their UIs, right?

604
00:23:37,226 --> 00:23:38,098
How many-- raise of hands.

605
00:23:38,098 --> 00:23:38,533
YIGIT BOYAR: Yeah!

606
00:23:38,534 --> 00:23:39,960
GEORGE MOUNT: That's right,
that's right. [INAUDIBLE].

607
00:23:39,960 --> 00:23:40,430
YIGIT BOYAR: Motion.

608
00:23:40,430 --> 00:23:42,440
GEORGE MOUNT: Get a
little motion in your UI.

609
00:23:42,440 --> 00:23:45,700
Well, one of the things
you see with data binding

610
00:23:45,700 --> 00:23:48,720
is without any kind
of a special work,

611
00:23:48,720 --> 00:23:50,920
you get this kind of
weird thing, where

612
00:23:50,920 --> 00:23:54,440
you click on something, and
it just pops into place.

613
00:23:54,440 --> 00:23:58,370
And that's kind of unfortunate.

614
00:23:58,370 --> 00:24:02,449
But we can do something pretty
simple to get a nice animation.

615
00:24:02,450 --> 00:24:03,820
And that's use transitions.

616
00:24:03,820 --> 00:24:05,639
How many of you use
transitions before?

617
00:24:05,640 --> 00:24:07,960
Yeah, this is something
introduced in KitKat.

618
00:24:07,960 --> 00:24:09,320
It's very useful.

619
00:24:09,320 --> 00:24:11,970
You get kind of automatic
animations with it.

620
00:24:11,970 --> 00:24:16,846
And what you can do is
add the onRebindCallback.

621
00:24:16,846 --> 00:24:20,840


622
00:24:20,840 --> 00:24:24,341
One of the functions
there is the onPreBind.

623
00:24:24,341 --> 00:24:26,090
And that's the thing
we really care about.

624
00:24:26,090 --> 00:24:29,730
This is evaluated before
the binding happens,

625
00:24:29,730 --> 00:24:31,640
before the bindings
are evaluated.

626
00:24:31,640 --> 00:24:32,820
And we don't know
what's going to happen.

627
00:24:32,820 --> 00:24:34,320
We just know that
something is going

628
00:24:34,320 --> 00:24:36,970
to happen when this is called.

629
00:24:36,970 --> 00:24:38,692
And what we do is we
get the sceneRoot.

630
00:24:38,692 --> 00:24:40,900
And then, of course, call
the beginDelayedTransition.

631
00:24:40,900 --> 00:24:44,720
And then you get a nice effect.

632
00:24:44,720 --> 00:24:45,400
Pretty nice.

633
00:24:45,400 --> 00:24:46,350
Pretty easy.

634
00:24:46,350 --> 00:24:47,270
Pretty simple.

635
00:24:47,270 --> 00:24:49,726
YIGIT BOYAR: Maybe we
should make this an API.

636
00:24:49,726 --> 00:24:50,970
Enable animations.

637
00:24:50,970 --> 00:24:52,345
GEORGE MOUNT:
That's a good idea.

638
00:24:52,345 --> 00:24:53,970
Yeah, we should do that.

639
00:24:53,970 --> 00:24:56,020
But this doesn't
work with everything.

640
00:24:56,020 --> 00:24:58,370
Let's look at this ad here.

641
00:24:58,370 --> 00:25:01,020
When we change the
field here, which

642
00:25:01,020 --> 00:25:04,560
changes the age of the user,
it just still pops in and out.

643
00:25:04,560 --> 00:25:07,270
All right, our transition system
doesn't handle every transition

644
00:25:07,270 --> 00:25:08,440
you might want.

645
00:25:08,440 --> 00:25:11,550
It handles the most common
ones-- fading in and out,

646
00:25:11,550 --> 00:25:14,940
or changing the position of the
view, those kinds of things.

647
00:25:14,940 --> 00:25:16,606
And you can do your
own transitions,

648
00:25:16,606 --> 00:25:18,480
but sometimes you want
something very custom,

649
00:25:18,480 --> 00:25:21,110
and you just want to do
an animation for that.

650
00:25:21,110 --> 00:25:22,699
So what do you do?

651
00:25:22,700 --> 00:25:25,620
Well, in this case, what we
can do is do it with setting.

652
00:25:25,620 --> 00:25:28,139
When the value is
actually set on the field,

653
00:25:28,140 --> 00:25:32,850
we can capture the state there
and animate it ourselves.

654
00:25:32,850 --> 00:25:35,500
So we create this
BindingAdapter.

655
00:25:35,500 --> 00:25:38,570
And we, of course, get the
old value and the new value.

656
00:25:38,570 --> 00:25:40,860
You don't have to take the
old value if you don't want,

657
00:25:40,861 --> 00:25:42,520
but in this case, we do want it.

658
00:25:42,520 --> 00:25:45,320
And then of course, if nothing
has changed, we have to,

659
00:25:45,320 --> 00:25:47,240
of course, not do anything.

660
00:25:47,240 --> 00:25:49,590
We don't want to do anything
if nothing's changed.

661
00:25:49,590 --> 00:25:52,279
But then we can just animate
the change right then and there.

662
00:25:52,279 --> 00:25:54,070
And you can do whatever
animation you want.

663
00:25:54,070 --> 00:25:56,429
I don't know what you'd
want to do on a text field,

664
00:25:56,430 --> 00:25:57,725
but you can do whatever
you want there.

665
00:25:57,725 --> 00:25:58,433
Maybe cross-fade.

666
00:25:58,433 --> 00:25:59,230
I don't know.

667
00:25:59,230 --> 00:26:00,453
Dependency injection.

668
00:26:00,453 --> 00:26:01,004
All right.

669
00:26:01,005 --> 00:26:01,880
Again, show of hands.

670
00:26:01,880 --> 00:26:04,530
How many people love
dependency injection?

671
00:26:04,530 --> 00:26:05,030
All right.

672
00:26:05,030 --> 00:26:05,290
YIGIT BOYAR: Nice.

673
00:26:05,290 --> 00:26:05,580
GEORGE MOUNT: All right.

674
00:26:05,580 --> 00:26:06,320
This is you guys.

675
00:26:06,320 --> 00:26:07,432
This is for you.

676
00:26:07,432 --> 00:26:09,640
When you're writing tests,
of course, what do you do?

677
00:26:09,640 --> 00:26:15,250
When you're binding adaptors,
you have an if statement.

678
00:26:15,250 --> 00:26:18,850
If it's testing settings or
you're not testing settings,

679
00:26:18,850 --> 00:26:20,719
you could do one or the other.

680
00:26:20,720 --> 00:26:23,519
But we're dependency
injection fans.

681
00:26:23,519 --> 00:26:24,560
We don't want to do that.

682
00:26:24,560 --> 00:26:25,909
That sucks.

683
00:26:25,910 --> 00:26:30,000
So what we do is create
a binding adapter

684
00:26:30,000 --> 00:26:33,375
that is no longer static.

685
00:26:33,375 --> 00:26:35,000
So we have an abstract
binding adapter.

686
00:26:35,000 --> 00:26:36,583
Of course, this could
be an interface.

687
00:26:36,583 --> 00:26:39,130
It doesn't have to be
an abstract base class.

688
00:26:39,130 --> 00:26:43,410
And we implement that interface
with your test version

689
00:26:43,410 --> 00:26:47,780
or your production version.

690
00:26:47,780 --> 00:26:50,720
But we don't know
which instance to call.

691
00:26:50,720 --> 00:26:51,600
We're data binding.

692
00:26:51,600 --> 00:26:53,600
We don't know whether you
want to call something

693
00:26:53,600 --> 00:26:55,090
on your test or your production.

694
00:26:55,090 --> 00:26:58,030
And so we need to know
what you're going to do.

695
00:26:58,030 --> 00:27:00,190
So we create this
data-binding component.

696
00:27:00,190 --> 00:27:02,200
Whenever we see an
instance method like that,

697
00:27:02,200 --> 00:27:06,580
we know that you are going
to give us an instance.

698
00:27:06,580 --> 00:27:09,710
And so you implement
the component.

699
00:27:09,710 --> 00:27:11,980
This is a generated
data-binding component

700
00:27:11,980 --> 00:27:14,900
that has that
generated getter in it.

701
00:27:14,900 --> 00:27:16,800
And you implement that.

702
00:27:16,800 --> 00:27:22,080
And you do whatever you need
to do to get your component.

703
00:27:22,080 --> 00:27:23,580
But then you have
to set it as well.

704
00:27:23,580 --> 00:27:24,949
So this is the default setter.

705
00:27:24,950 --> 00:27:27,890
You can also do it on each
inflate call if you want.

706
00:27:27,890 --> 00:27:31,570
But probably, you only want
to use one or the other.

707
00:27:31,570 --> 00:27:37,000
But you can do it every time you
inflate a view or bind a view.

708
00:27:37,000 --> 00:27:40,330
But you can also do it when
you're in your static binding

709
00:27:40,330 --> 00:27:40,830
adapters.

710
00:27:40,830 --> 00:27:42,899
You don't have to do it
just when you're doing

711
00:27:42,900 --> 00:27:44,074
instance-binding adapters.

712
00:27:44,074 --> 00:27:46,240
Now, I'll show you an
instance where this is useful.

713
00:27:46,240 --> 00:27:49,200
So we have this system where
we're going to load an image.

714
00:27:49,200 --> 00:27:51,860
And we want to load the
image using an image loader.

715
00:27:51,860 --> 00:27:53,790
We have cached already.

716
00:27:53,790 --> 00:27:55,270
And we want to get
that ImageLoader

717
00:27:55,270 --> 00:27:56,389
instance, of course.

718
00:27:56,390 --> 00:27:58,950
So of course get the component.

719
00:27:58,950 --> 00:28:00,769
Well, where did that
component come from?

720
00:28:00,769 --> 00:28:02,560
Well, we could get the
context, and then we

721
00:28:02,560 --> 00:28:04,090
could try to find
it in the context

722
00:28:04,090 --> 00:28:05,899
by casting it and [INAUDIBLE].

723
00:28:05,900 --> 00:28:06,650
Kind of a pain.

724
00:28:06,650 --> 00:28:09,560
So instead, what we
want to do is introduce

725
00:28:09,560 --> 00:28:10,902
data-binding component.

726
00:28:10,902 --> 00:28:12,590
Of course, this is
our instance one

727
00:28:12,590 --> 00:28:14,970
that we have in our application.

728
00:28:14,970 --> 00:28:19,650
And we can introduce it right
there in our BindingAdapter.

729
00:28:19,650 --> 00:28:22,690
And then we can use it.

730
00:28:22,690 --> 00:28:26,130
If you're using Dagger 2, what
you do is you create a module

731
00:28:26,130 --> 00:28:28,126
and provide the method.

732
00:28:28,126 --> 00:28:30,500
And then you create a component,
and you set your default

733
00:28:30,500 --> 00:28:31,690
component just like that.

734
00:28:31,690 --> 00:28:34,450


735
00:28:34,450 --> 00:28:35,820
All right.

736
00:28:35,820 --> 00:28:38,290
YIGIT BOYAR: So by the way,
if you're using data binding

737
00:28:38,290 --> 00:28:40,974
but did never write a binding
adapter, play with them.

738
00:28:40,974 --> 00:28:41,639
They're amazing.

739
00:28:41,640 --> 00:28:43,145
You can create your
own attributes.

740
00:28:43,145 --> 00:28:46,020
I'm seeing so many-- like,
we have to create them,

741
00:28:46,020 --> 00:28:48,000
so we can [? backport ?]
data binding.

742
00:28:48,000 --> 00:28:50,850
But they turn out to
be most widely abused,

743
00:28:50,850 --> 00:28:53,939
in a good way, features
of data binding.

744
00:28:53,940 --> 00:28:56,500
So one question we get
mainly is, how do I

745
00:28:56,500 --> 00:28:57,940
start using data binding?

746
00:28:57,940 --> 00:29:00,177
Because you already have an app.

747
00:29:00,177 --> 00:29:02,260
When you start from scratch,
yeah, it's very easy.

748
00:29:02,260 --> 00:29:03,890
But if you already
have an app, it

749
00:29:03,890 --> 00:29:06,599
doesn't make sense to
rewrite your layouts.

750
00:29:06,599 --> 00:29:07,639
This is unnecessary work.

751
00:29:07,640 --> 00:29:09,320
If it works, keep it.

752
00:29:09,320 --> 00:29:13,040
But in the new layouts, you
can start using data binding.

753
00:29:13,040 --> 00:29:16,190
So we wanted to go
through these levels.

754
00:29:16,190 --> 00:29:19,610
So to start using data binding,
you just enable it in Gradle.

755
00:29:19,610 --> 00:29:20,330
Super simple.

756
00:29:20,330 --> 00:29:22,480
Three lines.

757
00:29:22,480 --> 00:29:26,850
And then one thing you can start
doing today in any new layout

758
00:29:26,850 --> 00:29:29,360
you create is get to
the [? findViewById ?].

759
00:29:29,360 --> 00:29:31,540
There is like 25,
30 libraries that

760
00:29:31,540 --> 00:29:33,325
try to get to the
[? findViewById. ?]

761
00:29:33,325 --> 00:29:34,960
GEORGE MOUNT: Now it's 31.

762
00:29:34,960 --> 00:29:35,720
YIGIT BOYAR: Yeah.

763
00:29:35,720 --> 00:29:37,400
I think 31 is the last one.

764
00:29:37,400 --> 00:29:40,060
So I have never seen
anybody else creating it

765
00:29:40,060 --> 00:29:41,414
after we released data binding.

766
00:29:41,414 --> 00:29:43,330
This is like something
we should have released

767
00:29:43,330 --> 00:29:45,689
seven years ago,
like eight years ago,

768
00:29:45,690 --> 00:29:47,690
when we released Android

769
00:29:47,690 --> 00:29:52,450
So you just [? rep ?] your
layout into the layout tag,

770
00:29:52,450 --> 00:29:53,400
and then you are done.

771
00:29:53,400 --> 00:29:54,740
Nothing else you have to do.

772
00:29:54,740 --> 00:29:57,190
Now, with your code, you
had these findViewById

773
00:29:57,190 --> 00:29:59,980
or had these annotations
that you put on the views.

774
00:29:59,980 --> 00:30:01,460
You get rid of all of it.

775
00:30:01,460 --> 00:30:04,370
You get one binding
class for that layout,

776
00:30:04,370 --> 00:30:09,330
and it already has all the
views that has an ID as a field.

777
00:30:09,330 --> 00:30:11,530
These are public, final fields.

778
00:30:11,530 --> 00:30:12,850
And they are type-safe.

779
00:30:12,850 --> 00:30:14,469
Like, you don't need casting.

780
00:30:14,470 --> 00:30:17,330
If, by mistake-- like there is
one common mistake happens--

781
00:30:17,330 --> 00:30:19,669
is you use the same
ID in multiple places

782
00:30:19,670 --> 00:30:21,050
in different layouts.

783
00:30:21,050 --> 00:30:23,260
Someone changes an
ID in one place,

784
00:30:23,260 --> 00:30:25,370
your code doesn't crash
because the same ID

785
00:30:25,370 --> 00:30:26,847
was used somewhere else.

786
00:30:26,847 --> 00:30:29,180
But at runtime, you get a
crash, because you cannot find

787
00:30:29,180 --> 00:30:30,160
the view anymore.

788
00:30:30,160 --> 00:30:31,940
With data binding,
this cannot happen,

789
00:30:31,940 --> 00:30:33,780
because we create
them per layout.

790
00:30:33,780 --> 00:30:36,057
If someone, by mistake,
changes the ID,

791
00:30:36,057 --> 00:30:37,140
it's not going to compile.

792
00:30:37,140 --> 00:30:40,570


793
00:30:40,570 --> 00:30:43,610
The second part is binding
the UI, this very simple way

794
00:30:43,610 --> 00:30:45,270
that you can start
using data binding.

795
00:30:45,270 --> 00:30:47,270
Actually, you should.

796
00:30:47,270 --> 00:30:50,660
In my opinion, it's no-brainer,
but of course, I'm biased.

797
00:30:50,660 --> 00:30:52,560
In every single UI,
you have this thing--

798
00:30:52,560 --> 00:30:54,750
like your presenter or whatever.

799
00:30:54,750 --> 00:30:58,110
Once you log the data,
you go through the data,

800
00:30:58,110 --> 00:31:00,979
go through your views,
and set each of them.

801
00:31:00,980 --> 00:31:02,490
You need to handle the null.

802
00:31:02,490 --> 00:31:03,940
No, you need to catch them.

803
00:31:03,940 --> 00:31:04,440
Blah, blah.

804
00:31:04,440 --> 00:31:06,440
This is just, like,
so an unnecessary code

805
00:31:06,440 --> 00:31:08,230
that you have to write.

806
00:31:08,230 --> 00:31:09,650
You don't need to write.

807
00:31:09,650 --> 00:31:13,110
So just get
[? rid of ?] those IDs.

808
00:31:13,110 --> 00:31:15,780
Declare your variable
in the layout.

809
00:31:15,780 --> 00:31:20,740
This is a layout to display
the specific information.

810
00:31:20,740 --> 00:31:22,520
It's totally
intuitive to declare

811
00:31:22,520 --> 00:31:24,770
the inputs of the layout there.

812
00:31:24,770 --> 00:31:27,270
So you say, this layout
displays the user.

813
00:31:27,270 --> 00:31:30,610
You define it and
you use it inside.

814
00:31:30,610 --> 00:31:32,639
So when someone
inflates your layout

815
00:31:32,640 --> 00:31:35,140
and wants to do [? only, ?]
they already the binding clause.

816
00:31:35,140 --> 00:31:36,431
They could see all the setters.

817
00:31:36,431 --> 00:31:40,570
They know what the input
is for that layout.

818
00:31:40,570 --> 00:31:43,899
And [INAUDIBLE] update UI
method to get rid of all of it,

819
00:31:43,900 --> 00:31:46,190
the only thing you do is
set it on the binding,

820
00:31:46,190 --> 00:31:47,510
and it takes care of it.

821
00:31:47,510 --> 00:31:50,960
All of this happens without
any performance penalty.

822
00:31:50,960 --> 00:31:52,890
The third thing is callbacks.

823
00:31:52,890 --> 00:31:56,600
There is always the case you get
the binding, you get the fab,

824
00:31:56,600 --> 00:31:58,540
and then set the ClickListener.

825
00:31:58,540 --> 00:32:00,800
This is also so unnecessary.

826
00:32:00,800 --> 00:32:02,930
Just declare the presenters.

827
00:32:02,930 --> 00:32:06,110
Just say, when this button
is clicked, call this thing.

828
00:32:06,110 --> 00:32:08,805
The nice thing about this
implementation is you can just,

829
00:32:08,806 --> 00:32:11,180
when you are in Android Studio--
it happens all the time,

830
00:32:11,180 --> 00:32:12,330
s You go into a layout.

831
00:32:12,330 --> 00:32:14,669
OK, what happens if
user clicks and you

832
00:32:14,670 --> 00:32:18,545
try to search references
of that view ID

833
00:32:18,545 --> 00:32:20,270
and then see where
the ClickListener is.

834
00:32:20,270 --> 00:32:21,831
There's a couple of steps.

835
00:32:21,832 --> 00:32:23,790
Here, you can just click
and go to that method,

836
00:32:23,790 --> 00:32:24,895
and find implementation.

837
00:32:24,895 --> 00:32:28,340


838
00:32:28,340 --> 00:32:31,379
So especially if you
are starting a new app

839
00:32:31,380 --> 00:32:34,960
from scratch, observability
might be very, very handy.

840
00:32:34,960 --> 00:32:37,800
So instead of having
this simple user clause,

841
00:32:37,800 --> 00:32:40,379
you could make extend
BaseObservable.

842
00:32:40,380 --> 00:32:43,150
There's also an interface if
you don't want the extend.

843
00:32:43,150 --> 00:32:45,710
You make it bindable.

844
00:32:45,710 --> 00:32:47,570
And then whenever
the value changes,

845
00:32:47,570 --> 00:32:49,240
you want to find this change.

846
00:32:49,240 --> 00:32:53,210
And we will take care
of updating the UI.

847
00:32:53,210 --> 00:32:56,382
And there is one of the
new features-- I highly

848
00:32:56,382 --> 00:32:58,340
recommend is the features
two-way data binding.

849
00:32:58,340 --> 00:33:01,340
Now, two-way data binding
when you have complex model

850
00:33:01,340 --> 00:33:03,189
is not very easy to use.

851
00:33:03,190 --> 00:33:05,500
But like all of us
have login forms--

852
00:33:05,500 --> 00:33:08,230
all these simple
form kind of layouts

853
00:33:08,230 --> 00:33:09,952
that people has to fill.

854
00:33:09,952 --> 00:33:13,056
And there's a lot of
logic going in there.

855
00:33:13,056 --> 00:33:14,430
Instead of writing
that code, you

856
00:33:14,430 --> 00:33:17,980
can just let two-way
binding handle all of it

857
00:33:17,980 --> 00:33:19,480
and return your object.

858
00:33:19,480 --> 00:33:23,270
So for a layout like
this, all you [INAUDIBLE]

859
00:33:23,270 --> 00:33:25,610
is create the smaller
class, make all of them

860
00:33:25,610 --> 00:33:26,490
observable field.

861
00:33:26,490 --> 00:33:28,900
Like, you have only one
instance of that clause.

862
00:33:28,900 --> 00:33:30,850
It doesn't matter
how expensive it is.

863
00:33:30,850 --> 00:33:34,070
So make everything
observable fields.

864
00:33:34,070 --> 00:33:37,409
And then when we do that, our
layout will look like this.

865
00:33:37,410 --> 00:33:40,630
We have real data
that enables, disables

866
00:33:40,630 --> 00:33:42,270
the button or whatever logic.

867
00:33:42,270 --> 00:33:44,356
And you have the form model.

868
00:33:44,356 --> 00:33:49,140
And for each of the input
fields, you use them.

869
00:33:49,140 --> 00:33:50,920
So you say, this is the name.

870
00:33:50,920 --> 00:33:53,390
Notice that it's
a two-way binding.

871
00:33:53,390 --> 00:33:54,460
Or you have a button.

872
00:33:54,460 --> 00:34:00,480
You say if my real data model
enables it, make it enabled.

873
00:34:00,480 --> 00:34:00,980
You do this.

874
00:34:00,980 --> 00:34:03,217
So you cannot do this
in every single layout,

875
00:34:03,217 --> 00:34:04,300
so you need to be careful.

876
00:34:04,300 --> 00:34:08,929
Bu something that you can
encapsulate-- it's about forms,

877
00:34:08,929 --> 00:34:11,031
or [INAUDIBLE] place
you want to grab

878
00:34:11,031 --> 00:34:13,159
data-- it's so much
cleaner, so much simpler,

879
00:34:13,159 --> 00:34:15,940
and you will save time.

880
00:34:15,940 --> 00:34:17,420
So just do this.

881
00:34:17,420 --> 00:34:19,895
So now you have a binding
layout that gives you

882
00:34:19,895 --> 00:34:21,710
an object that has the data.

883
00:34:21,710 --> 00:34:25,840
And then you do whatever you
want to do with that data.

884
00:34:25,840 --> 00:34:28,739
So let me quickly go through
some of the best practices,

885
00:34:28,739 --> 00:34:31,520
because data binding
is very powerful.

886
00:34:31,520 --> 00:34:34,699
But just because there's a way
to do things with data binding

887
00:34:34,699 --> 00:34:38,110
does not mean that you should
do everything with data binding.

888
00:34:38,110 --> 00:34:41,810
So something you need to be
careful when using data binding

889
00:34:41,810 --> 00:34:44,960
is what expressions
you put there.

890
00:34:44,960 --> 00:34:47,070
So if you put an expression
like the [? same ?]

891
00:34:47,070 --> 00:34:50,000
and user click this
button, send the money,

892
00:34:50,000 --> 00:34:51,760
you should not do this.

893
00:34:51,760 --> 00:34:54,780
Like, it's so wrong,
because sending the money

894
00:34:54,780 --> 00:34:56,580
is completely about
your application.

895
00:34:56,580 --> 00:34:58,259
This is like it's
your business logic.

896
00:34:58,260 --> 00:35:00,520
It has nothing to
do with your UI.

897
00:35:00,520 --> 00:35:03,110
The only thing you
care about is that user

898
00:35:03,110 --> 00:35:04,840
clicked on that button.

899
00:35:04,840 --> 00:35:08,330
This is where the responsibility
of data binding stops.

900
00:35:08,330 --> 00:35:09,580
So you get rid of this.

901
00:35:09,580 --> 00:35:10,580
Don't do that.

902
00:35:10,580 --> 00:35:13,779
Instead, put something like
presenter::onSendClick,

903
00:35:13,780 --> 00:35:16,872
so that presenter clause
can be tested by itself.

904
00:35:16,872 --> 00:35:21,029
And then you will have
a reliable application.

905
00:35:21,030 --> 00:35:23,280
I know it's not very clear
where you want to stop.

906
00:35:23,280 --> 00:35:26,890
Like how much can I
data-bind, and how much

907
00:35:26,890 --> 00:35:28,549
I should do in the Java code?

908
00:35:28,550 --> 00:35:30,260
Well, you use your intuition.

909
00:35:30,260 --> 00:35:32,144
You know, use what
works best for you.

910
00:35:32,144 --> 00:35:34,060
GEORGE MOUNT: So you're
saying change the name

911
00:35:34,060 --> 00:35:35,660
of our function, right?

912
00:35:35,660 --> 00:35:36,549
YIGIT BOYAR: Yeah,
that was the goal.

913
00:35:36,550 --> 00:35:37,070
GEORGE MOUNT: Yeah, yeah, OK.

914
00:35:37,070 --> 00:35:38,903
YIGIT BOYAR: Don't call
[? our ?] functions.

915
00:35:38,903 --> 00:35:39,720
Use [INAUDIBLE].

916
00:35:39,720 --> 00:35:40,511
That will solve it.

917
00:35:40,511 --> 00:35:41,636
[LAUGHTER]

918
00:35:41,636 --> 00:35:43,730
But anyway, data binding
works with program,

919
00:35:43,730 --> 00:35:47,240
because we do everything in the
compile time [? set ?] detail.

920
00:35:47,240 --> 00:35:50,540
So another thing
is if it is related

921
00:35:50,540 --> 00:35:51,950
to UI, just put it there.

922
00:35:51,950 --> 00:35:53,874
You don't need to oh,
my god, I shouldn't put

923
00:35:53,874 --> 00:35:55,040
any logic in my [INAUDIBLE].

924
00:35:55,040 --> 00:35:57,170
It's like that doesn't
make any sense.

925
00:35:57,170 --> 00:36:00,260
If it is about how that
layout looks, if it is simple,

926
00:36:00,260 --> 00:36:02,280
just keep it there,
because the important thing

927
00:36:02,280 --> 00:36:04,150
is when you look
at that layout file

928
00:36:04,150 --> 00:36:06,470
three months after
in Android Studio,

929
00:36:06,470 --> 00:36:08,993
then you have an idea
what that layout does.

930
00:36:08,994 --> 00:36:09,910
That's the point here.

931
00:36:09,910 --> 00:36:12,420
Like, they should
be declarative,

932
00:36:12,420 --> 00:36:15,460
they should explain themselves.

933
00:36:15,460 --> 00:36:19,190
But if you put an
expression like this there,

934
00:36:19,190 --> 00:36:22,310
there is no way you read it
and understand what it's doing.

935
00:36:22,310 --> 00:36:23,380
It's just confusing.

936
00:36:23,380 --> 00:36:24,910
Don't do something like this.

937
00:36:24,910 --> 00:36:26,960
They need to be
simple expressions.

938
00:36:26,960 --> 00:36:29,010
So get rid of it.

939
00:36:29,010 --> 00:36:32,970
Like, create a method
that gives a short name.

940
00:36:32,970 --> 00:36:34,640
And then use that one instead.

941
00:36:34,640 --> 00:36:36,656
If they are not
readable-- if you realize

942
00:36:36,657 --> 00:36:38,490
they are getting long,
then you are probably

943
00:36:38,490 --> 00:36:40,129
doing something wrong.

944
00:36:40,130 --> 00:36:41,320
So it's a method we created.

945
00:36:41,320 --> 00:36:43,611
GEORGE MOUNT: Yeah, we can
also-- something to mention,

946
00:36:43,611 --> 00:36:47,060
though, is we can also do
string functions there.

947
00:36:47,060 --> 00:36:49,210
So if you want to do
string substitutions,

948
00:36:49,210 --> 00:36:51,876
you can use the string formatter
right there in your expressions

949
00:36:51,876 --> 00:36:53,504
as well.

950
00:36:53,504 --> 00:36:55,420
YIGIT BOYAR: So another
thing is RecyclerView.

951
00:36:55,420 --> 00:36:57,400
By the way, two
days ago, we just

952
00:36:57,400 --> 00:37:01,610
published a sample application
that uses data binding

953
00:37:01,610 --> 00:37:03,290
and RecyclerView on GitHub.

954
00:37:03,290 --> 00:37:07,070
And I sent it into the Spaces
link, so you can find it there.

955
00:37:07,070 --> 00:37:09,140
But one thing you
need to be careful of

956
00:37:09,140 --> 00:37:12,009
is if you are using data binding
with RecyclerView, which you

957
00:37:12,010 --> 00:37:14,756
should because it generates
the [? view ?] holder for you,

958
00:37:14,756 --> 00:37:17,140
when you bind a view,
you should always

959
00:37:17,140 --> 00:37:19,089
call executePendingBindings.

960
00:37:19,090 --> 00:37:21,660
If you don't do this,
binding will defer it

961
00:37:21,660 --> 00:37:24,509
until the next layout and
RecyclerView will get unhappy,

962
00:37:24,510 --> 00:37:27,580
because the view didn't
tell us what the height is.

963
00:37:27,580 --> 00:37:28,830
So there's a couple of things.

964
00:37:28,830 --> 00:37:30,660
These are a couple
of little examples

965
00:37:30,660 --> 00:37:33,540
that people did with
binding adapters mostly.

966
00:37:33,540 --> 00:37:35,759
Wanted to mention them.

967
00:37:35,760 --> 00:37:36,810
You can do this.

968
00:37:36,810 --> 00:37:37,980
This is like HTML.

969
00:37:37,980 --> 00:37:41,135
I have a text view,
and it's an image URL.

970
00:37:41,135 --> 00:37:43,730
Well, that should be
probably imageView.

971
00:37:43,730 --> 00:37:45,624
But it's an image URL.

972
00:37:45,624 --> 00:37:47,665
And then it just works.

973
00:37:47,666 --> 00:37:48,790
You have a binding adapter.

974
00:37:48,790 --> 00:37:49,894
You paste it to there.

975
00:37:49,894 --> 00:37:51,560
Everything is fine
properly [INAUDIBLE].

976
00:37:51,560 --> 00:37:54,786
And you know what
that image shows.

977
00:37:54,786 --> 00:37:56,160
You don't need
the ID or whatever

978
00:37:56,160 --> 00:37:58,930
to make it self-explanatory.

979
00:37:58,930 --> 00:38:01,180
It's invisible.

980
00:38:01,180 --> 00:38:03,571
Oh, here is an image URL.

981
00:38:03,571 --> 00:38:05,589
So you can have
multiple parameters.

982
00:38:05,590 --> 00:38:08,040
Binding adapters can
receive multiple parameters.

983
00:38:08,040 --> 00:38:10,630
You could say, OK,
this is the placeholder

984
00:38:10,630 --> 00:38:11,800
and this is the image URL.

985
00:38:11,800 --> 00:38:14,532
You have a binding adapter that
receives these two attributes.

986
00:38:14,532 --> 00:38:17,130
We call it with
these two values.

987
00:38:17,130 --> 00:38:19,770
We [? call it ?] drawable,
and it's an actual drawable.

988
00:38:19,770 --> 00:38:21,520
You don't need to
do it yourself.

989
00:38:21,520 --> 00:38:23,610
And you can
[? name ?] your logic.

990
00:38:23,610 --> 00:38:28,020
It works very well with testing,
because in testing, you just

991
00:38:28,020 --> 00:38:30,590
provide a dummy adapter
that doesn't do anything.

992
00:38:30,590 --> 00:38:32,690
And then now all
your tests run faster

993
00:38:32,690 --> 00:38:35,460
without making
that work request.

994
00:38:35,460 --> 00:38:36,650
The other thing-- font.

995
00:38:36,650 --> 00:38:40,300
This has been requested on
the text view for many years.

996
00:38:40,300 --> 00:38:43,480
We haven't [? invented ?]
it until data binding.

997
00:38:43,480 --> 00:38:47,570
Now, you could just create
your own attributes,

998
00:38:47,570 --> 00:38:50,080
call it app:font,
and then it works.

999
00:38:50,080 --> 00:38:51,840
There's actually a
project on GitHub

1000
00:38:51,840 --> 00:38:54,152
from [? Lisa ?] that does this.

1001
00:38:54,152 --> 00:38:55,120
It's super cool.

1002
00:38:55,120 --> 00:38:57,932
Super convenient.

1003
00:38:57,932 --> 00:39:00,200
And you could use
vector drawables.

1004
00:39:00,200 --> 00:39:02,649
So [? now ?] today you cannot
use vector drawables in XML,

1005
00:39:02,650 --> 00:39:03,150
right?

1006
00:39:03,150 --> 00:39:03,810
No.

1007
00:39:03,810 --> 00:39:06,435
If you use data binding, you can
actually use vector drawables.

1008
00:39:06,435 --> 00:39:09,740
You just create the binding
adapter for that and do it.

1009
00:39:09,740 --> 00:39:12,069
Another one here
is-- like, it's so

1010
00:39:12,070 --> 00:39:13,715
common in applications
[INAUDIBLE]

1011
00:39:13,715 --> 00:39:15,630
dimension image margin.

1012
00:39:15,630 --> 00:39:20,540
And then you have something
like a dimension picture size.

1013
00:39:20,540 --> 00:39:22,990
Dimension picture size
and picture margin,

1014
00:39:22,990 --> 00:39:24,569
so that you could
align your views.

1015
00:39:24,570 --> 00:39:26,190
So you create all
these dimensions,

1016
00:39:26,190 --> 00:39:27,760
you don't need too many more.

1017
00:39:27,760 --> 00:39:30,110
You can just use data
binding to say, hey,

1018
00:39:30,110 --> 00:39:32,180
this thing is picture
size plus picture margin.

1019
00:39:32,180 --> 00:39:33,372
That's it.

1020
00:39:33,372 --> 00:39:35,330
It's like, this should
have been there already.

1021
00:39:35,330 --> 00:39:36,470
But it wasn't.

1022
00:39:36,470 --> 00:39:36,970
All right.

1023
00:39:36,970 --> 00:39:40,240
So once you start
experimenting, these

1024
00:39:40,240 --> 00:39:42,750
are things we did
not think about.

1025
00:39:42,750 --> 00:39:43,910
Remember the image URL.

1026
00:39:43,910 --> 00:39:46,410
There was something we thought
[? about. ?] And that was it.

1027
00:39:46,410 --> 00:39:50,870
People came up with this
font, the margin thing.

1028
00:39:50,870 --> 00:39:53,089
It's just new stuff you
can do with data binding.

1029
00:39:53,090 --> 00:39:55,020
So go on, explore
[? around with ?] it.

1030
00:39:55,020 --> 00:39:55,650
Thank you.

1031
00:39:55,650 --> 00:39:56,650
GEORGE MOUNT: Thank you.

1032
00:39:56,650 --> 00:39:58,490
[APPLAUSE]

1033
00:39:58,490 --> 00:39:59,689


1034
00:39:59,690 --> 00:40:03,340
[MUSIC PLAYING]

1035
00:40:03,340 --> 00:40:15,408


